#!/usr/bin/env python3
##############################################################################
#
#         ,/
#       ,'/
#     ,' /___,  888888 88     888888  dP""b8 888888 88""Yb 88  dP""b8
#   .'__   ,'   88__   88     88__   dP   `"   88   88__dP 88 dP   `"
#      / ,'     88""   88  .o 88""   Yb        88   88"Yb  88 Yb
#     /,'       888888 88ood8 888888  YboodP   88   88  Yb 88  YboodP
#    /'
#
# ----------------------------------------------------------------------------
#                           Music Library Manager
# ----------------------------------------------------------------------------
#
#   Author: Daniel Li
#   Date: Sep 04 2024
#
#   Dependencies:
#     - python
#     - click
#     - ffmpeg: for update command
#     - adb: for adb backend
#
##############################################################################

import click
import datetime
import hashlib
import os
import re
import shutil
import subprocess
import sys
import zlib

default_root = os.path.dirname(os.path.realpath(__file__))

# The list of valid groups. These should match the order in the manifest.
GROUPS = [('core', 'Electric'), ('extra', 'Electric Extra')]
GROUPIDS = [groupid for groupid, _ in GROUPS]

##############################################################################
# Tag Overrides
##############################################################################

# The artist name and song title are automatically generated by converting
# their respective identifiers to uppercase and replacing dashes with spaces.
# For the majority of cases, this works fabulously. There are of course a few
# exceptions. For those, we override the automatically generated tag values
# here.

ARTIST_NAME_OVERRIDES = {
    'a-39': 'A-39',
    'ex-lyd': 'EX-LYD',
    'tn-shi': 'TN-SHI'
}

SONG_TITLE_OVERRIDES = {
    ('au5', 'moonland-derpcat-remix'): 'MOONLAND (DERPCAT REMIX)',
    ('camellia', '1f1e33'): '#1F1E33'
}

##############################################################################
# Utility Functions
##############################################################################

def err(message):
    click.echo(f'\033[1;31merror:\033[0m {message}', err=True)

def warn(message):
    click.echo(f'\033[1;33mwarning:\033[0m {message}', err=True)

def confirm(prompt, default=False):
    """Prompt the user for confirmation.

    If the response is empty (ie. the user simply pressed Enter),
    the specified default is returned if provided, otherwise False.
    If the response is 'Y' or 'y', returns True, otherwise returns False.
    """
    reply = input(prompt)
    return default if len(reply) == 0 else reply == 'y' or reply == 'Y'

def get_file_hash(filename):
    """Calculate the MD5 hash of a file and return it as a hex string.

    See https://stackoverflow.com/a/59056837
    """
    with open(filename, 'rb') as file:
        md5 = hashlib.md5()
        while chunk := file.read(65536):
            md5.update(chunk)
    return md5.hexdigest()

class Tags:
    def __init__(self, title, artist, album):
        self.title = title
        self.artist = artist
        self.album = album

    def hash(self):
        """Calculate the tag hash. Returns a 32-bit integer."""
        return 0xffffffff & zlib.crc32(
            self.title.encode('utf-8') +
            self.artist.encode('utf-8') +
            self.album.encode('utf-8'))

    def apply(self, input_file, output_file):
        """Apply tags to the specified input_file and write to output_file."""
        subprocess.run([
            'ffmpeg', '-y', '-hide_banner', '-loglevel', 'warning',
            '-i', input_file,
            '-codec', 'copy',
            '-map', '0:a',
            '-map_metadata', '-1',
            '-metadata', 'title=' + self.title,
            '-metadata', 'artist=' + self.artist,
            '-metadata', 'album=' + self.album,
            '-bitexact',
            '-f', 'mp3', output_file], check=True)

##############################################################################
# Manifest
##############################################################################

class Manifest:
    def __init__(self):
        self._groups = {groupid: Group(groupid, album) for groupid, album in GROUPS}

    def group(self, groupid):
        return self._groups[groupid]

    def groups(self):
        # cross our fingers for insertion order
        return self._groups.values()

    def __contains__(self, groupid):
        return groupid in self._groups

    def songs(self):
        return (song for group in self.groups() for song in group.songs())

class Group:
    def __init__(self, id, album):
        self.id = id
        self.album = album
        self._songs = {}

    def songs_unsorted(self):
        return self._songs.values()

    def songs(self):
        return sorted(self._songs.values(), key=lambda song: song.baseid)

    def __contains__(self, baseid):
        return baseid in self._songs

    def __len__(self):
        return len(self._songs)

    def add(self, artist, title, date, file_hash, tag_hash):
        song = Song(self, artist, title, date, file_hash, tag_hash)
        self._songs[song.baseid] = song
        return song

class Song:
    def __init__(self, group, artist, title, date, file_hash, tag_hash):
        self.group = group
        self.artist = artist
        self.title = title
        self.date = date
        self.file_hash = file_hash
        self.tag_hash = tag_hash

    @property
    def groupid(self):
        return self.group.id

    @property
    def baseid(self):
        return (self.artist, self.title)

    @property
    def fullid(self):
        return (self.groupid, self.artist, self.title)

    def __str__(self):
        return f'{self.groupid}/{self.artist}.{self.title}'

    def tags(self):
        return Tags(
            (SONG_TITLE_OVERRIDES[self.baseid] if self.baseid in SONG_TITLE_OVERRIDES
                else self.title.upper().replace('-', ' ')),
            (ARTIST_NAME_OVERRIDES[self.artist] if self.artist in ARTIST_NAME_OVERRIDES
                else self.artist.upper().replace('-', ' ')),
            self.group.album)

    def filename(self):
        assert self.file_hash is not None
        return f'{self.artist}.{self.title}.{self.file_hash}.mp3'

    def filepath(self):
        return f'{self.groupid}/{self.filename()}'

class ManifestParseError(Exception):
    pass

def read_manifest(file):
    """Read the manifest from a file object."""

    # regex for group header
    group_header_regex = re.compile('\\[([a-z]+)\\]')
    # regex for artist and title fields
    ident_regex = re.compile('[0-9a-z]+(?:-[0-9a-z]+)*')
    # regex for date field
    date_regex = re.compile('([0-9]{4})-([0-9]{2})-([0-9]{2})')
    # regex for file_hash field
    file_hash_regex = re.compile('[0-9a-f]{32}')
    # regex for tag_hash field
    tag_hash_regex = re.compile('[0-9a-f]{8}')

    manifest = Manifest()
    line_num = 0
    current_group = None

    for line in file:
        # increment line number before the loop to catch continue
        line_num += 1
        # remove trailing newline
        line = line[:-1]

        match = group_header_regex.fullmatch(line)
        if match:
            groupid = match.group(1)
            if groupid not in manifest:
                raise ManifestParseError(f"Invalid group '{groupid}' at line {line_num}")
            current_group = manifest.group(groupid)
            continue

        if current_group is None:
            raise ManifestParseError(f"Group header required before line {line_num}")

        fields = line.split(' ')
        if len(fields) != 5:
            raise ManifestParseError(f"Incorrect number of fields at line {line_num}")

        artist = fields[0]
        if not ident_regex.fullmatch(artist):
            raise ManifestParseError(f"Invalid artist '{artist}' at line {line_num}")

        title = fields[1]
        if not ident_regex.fullmatch(title):
            raise ManifestParseError(f"Invalid title '{title}' at line {line_num}")

        if (artist, title) in current_group:
            raise ManifestParseError(f"Duplicate song '{artist}.{title}' at line {line_num}")

        date_str = fields[2]
        match = date_regex.fullmatch(date_str)
        if not match:
            raise ManifestParseError(f"Invalid date '{date_str}' at line {line_num}")
        date = datetime.date(int(match.group(1)), int(match.group(2)), int(match.group(3)))

        file_hash_str = fields[3]
        if not file_hash_regex.fullmatch(file_hash_str):
            raise ManifestParseError(f"Invalid file hash '{file_hash_str}' at line {line_num}")
        file_hash = file_hash_str

        tag_hash_str = fields[4]
        if not tag_hash_regex.fullmatch(tag_hash_str):
            raise ManifestParseError(f"Invalid tag hash '{tag_hash_str}' at line {line_num}")
        tag_hash = int(tag_hash_str, 16)

        current_group.add(artist, title, date, file_hash, tag_hash)

    return manifest

def write_manifest(manifest, file):
    """Write the manifest to a file object."""
    for group in manifest.groups():
        file.write(f'[{group.id}]\n')
        for song in group.songs():
            artist = song.artist
            title = song.title
            date = song.date.strftime("%Y-%m-%d")
            file_hash = song.file_hash
            tag_hash = '%08x' % song.tag_hash
            file.write(f'{artist} {title} {date} {file_hash} {tag_hash}\n')

##############################################################################
# Remote Backends
##############################################################################

remote_backends = {}

def remote_backend(name):
    def decorator(cls):
        remote_backends[name] = cls
        return cls
    return decorator

def create_backend(param):
    name = 'file'
    regex = re.compile('^[a-z]+:')
    match = regex.match(param)
    if match:
        name = param[:match.end() - 1]
        param = param[match.end():]
    if name not in remote_backends:
        err(f"unrecognized backend '{name}'")
        sys.exit(1)
    return remote_backends[name](param)

@remote_backend('file')
class FileBackend:
    def __init__(self, param):
        self.root = param

    def list(self):
        return {f'{groupid}/{file}'
                for groupid in GROUPIDS
                for file in os.listdir(os.path.join(self.root, groupid))
                if not file.startswith('.') and file.endswith('.mp3')}

    def has(self, filepath):
        return os.path.exists(os.path.join(self.root, filepath))

    def pull(self, local_root, pull_files):
        for filepath in pull_files:
            print(f"Copying {filepath}")
            src = os.path.join(self.root, filepath)
            dest = os.path.join(local_root, filepath)
            shutil.copyfile(src, dest)

    def push(self, local_root, push_files, prune_files):
        for filepath in push_files:
            print(f"Copying {filepath}")
            src = os.path.join(local_root, filepath)
            dest = os.path.join(self.root, filepath)
            shutil.copyfile(src, dest)
        for filepath in prune_files:
            print(f"Removing {filepath}")
            os.remove(os.path.join(self.root, filepath))

@remote_backend('adb')
class AdbBackend:
    def __init__(self, param):
        self.root = param if len(param) else '/storage/emulated/0/Music'
        self._filelist = None

    def list(self):
        args = ['adb', 'shell', f"cd '{self.root}' && find {' '.join(GROUPIDS)} -mindepth 1 -maxdepth 1 -iname '*.mp3'"]
        output = subprocess.run(args, stdout=subprocess.PIPE, text=True, check=True).stdout
        return set(output.splitlines())

    def has(self, filepath):
        if self._filelist is None:
            self._filelist = self.list()
        return filepath in self._filelist

    def pull(self, pull_files):
        for filepath in pull_files:
            print(f"Copying {filepath}")
            src = f'{self.root}/{filepath}'
            dest = os.path.join(local_root, filepath)
            subprocess.run(['adb', 'pull', src, dest], check=True)

    def push(self, local_root, push_files, prune_files):
        for filepath in push_files:
            print(f"Copying {filepath}")
            src = os.path.join(local_root, filepath)
            dest = f'{self.root}/{filepath}'
            subprocess.run(['adb', 'push', src, dest], check=True)
        if len(prune_files) > 0:
            script = f"cd '{self.root}' && rm -f"
            for filepath in prune_files:
                script += f" '{filepath}'"
            subprocess.run(['adb', 'shell', script], check=True)

##############################################################################
# Command Line Parsing
##############################################################################

class Context:
    def __init__(self, root, manifest_file):
        self.root = root
        self.manifest_file = manifest_file

    def load_manifest(self):
        with open(self.manifest_file) as file:
            return read_manifest(file)

    def save_manifest(self, manifest):
        with open(self.manifest_file, 'w', newline='\n') as file:
            write_manifest(manifest, file)

@click.group()
@click.option('-r', '--root', help='root directory', metavar='DIR', default=default_root, show_default=True)
@click.option('-m', '--manifest', help='manifest file relative to root', metavar='FILE', default='manifest.txt', show_default=True)
@click.pass_context
def main(ctx, root, manifest):
    """Electric music library manager."""
    manifest_file = os.path.join(root, manifest)
    ctx.obj = Context(root, manifest_file)

#-----------------------------------------------------------------------------
# Command: update
#-----------------------------------------------------------------------------

@main.command()
@click.pass_obj
def update(context):
    """Import new music and fix tags."""

    import_file_regex = re.compile('([a-z]+)\\.([0-9a-z]+(?:-[0-9a-z]+)*)\\.([0-9a-z]+(?:-[0-9a-z]+)*)\\.mp3')

    class UpdateItem:
        def __init__(self, song, tags, source_file):
            self.song = song
            self.tags = tags
            self.source_file = source_file

    class ImportItem(UpdateItem):
        def log(self):
            print(f'Importing {self.song}')

    class RetagItem(UpdateItem):
        def log(self):
            print(f'Retagging {self.song}')

    queue_dir = os.path.join(context.root, 'queue')
    manifest = context.load_manifest()

    items = []

    # search for incorrectly tagged files in manifest
    for song in manifest.songs():
        tags = song.tags()
        if song.tag_hash == tags.hash():
            continue # tags are correct

        print(f"\033[1;36mretag:\033[0m {song}")
        print(f"  title: {tags.title}")
        print(f"  artist: {tags.artist}")
        print(f"  album: {tags.album}")
        items.append(RetagItem(song, tags, os.path.join(context.root, song.filepath())))

    # go through queue and add files to import
    for filename in os.listdir(queue_dir):
        match = import_file_regex.fullmatch(filename)
        if not match:
            continue

        groupid = match.group(1)
        if groupid not in manifest:
            warn(f"{filename}: invalid group '{groupid}'")
            continue

        group = manifest.group(groupid)
        artist = match.group(2)
        title = match.group(3)
        if (artist, title) in group:
            warn(f"{filename}: song already exists")
            continue

        date = datetime.date.today()
        song = group.add(artist, title, date, None, None)
        tags = song.tags()
        print(f"\033[1;32mimport:\033[0m {song}")
        print(f"  title: {tags.title}")
        print(f"  artist: {tags.artist}")
        print(f"  album: {tags.album}")
        items.append(ImportItem(song, tags, os.path.join(queue_dir, filename)))

    if len(items) == 0:
        return

    if not confirm('Proceed [Y/n]? ', True):
        sys.exit(2)

    # process update items
    for item in items:
        item.log()

        temp_file = item.source_file + '~'
        try:
            os.remove(temp_file)
        except FileNotFoundError:
            pass
        item.tags.apply(item.source_file, temp_file)

        item.song.file_hash = get_file_hash(temp_file)
        item.song.tag_hash = item.tags.hash()
        dest_file = os.path.join(context.root, item.song.filepath())
        if os.path.exists(dest_file):
            os.remove(temp_file)
        else:
            os.rename(temp_file, dest_file)

    # save the manifest
    context.save_manifest(manifest)

    # now it should be safe to cleanup
    for item in items:
        os.remove(item.source_file)

#-----------------------------------------------------------------------------
# Command: maint
#-----------------------------------------------------------------------------

@main.command()
@click.option('--prune', is_flag=True, help='delete extraneous files')
@click.option('--verify', is_flag=True, help='verify file integrity')
@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
@click.pass_obj
def maint(context, prune, verify, yes):
    """Manage the music directory."""

    manifest = context.load_manifest()
    ok = True
    orphans = []

    for group in manifest.groups():
        try:
            filenames = set([file for file in os.listdir(os.path.join(context.root, group.id)) if not file.startswith('.') and file.endswith('.mp3')])
        except FileNotFoundError:
            filenames = set()
        for song in group.songs():
            filename = song.filename()
            if filename not in filenames:
                warn(f'missing file: {group.id}/{filename}')
                ok = False
                continue

            filenames.remove(filename)
            if not verify:
                continue

            filename = os.path.join(context.root, song.filepath())
            try:
                file_hash = get_file_hash(filename)
            except OSError as e:
                err(f"{song}: failed to get file hash: {e.strerror}")
                ok = False
                continue

            if file_hash != song.file_hash:
                warn(f"{song}: hashes differ")
                ok = False

        for filename in sorted(filenames):
            orphans.append(os.path.join(group.id, filename))

    for filename in orphans:
        warn(f'orphan: {filename}')
        if prune and (yes or confirm('Delete [Y/n]? ', True)):
            os.remove(os.path.join(context.root, filename))
        else:
            ok = False

    if not ok:
        sys.exit(1)

#-----------------------------------------------------------------------------
# Command: pull
#-----------------------------------------------------------------------------

@main.command()
@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
@click.argument('remotes', nargs=-1, required=True)
@click.pass_obj
def pull(context, dry_run, yes, remotes):
    """Get missing files from a remote.

    If multiple remotes are specified, missing files will be searched in each
    remote and the first remote that has the file will be used.
    """
    remotes = [(create_backend(remote), []) for remote in remotes]
    manifest = context.load_manifest()
    need_pull = False

    for song in manifest.songs():
        filepath = song.filepath()
        if os.path.exists(os.path.join(context.root, filepath)):
            continue
        for backend, files in remotes:
            if backend.has(filepath):
                files.append(filepath)
                need_pull = True
                break
        else:
            warn(f"could not find source for {filepath}")

    if not need_pull:
        return # nothing to do
    if dry_run:
        return
    if not (yes or confirm('Proceed [Y/n]? ', True)):
        sys.exit(2)
    for backend, files in remotes:
        if len(files):
            backend.pull(context.root, files)

#-----------------------------------------------------------------------------
# Command: push
#-----------------------------------------------------------------------------

@main.command()
@click.option('--prune', is_flag=True, help='prune extraneous files')
@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
@click.argument('remote')
@click.pass_obj
def push(context, prune, dry_run, yes, remote):
    """Send files to a remote."""
    backend = create_backend(remote)
    manifest = context.load_manifest()
    filelist = backend.list()
    push_files = []
    prune_files = []

    for song in manifest.songs():
        filepath = song.filepath()
        if filepath in filelist:
            if prune:
                filelist.remove(filepath)
            continue

        # check if local root has the file
        if os.path.exists(os.path.join(context.root, filepath)):
            print(f"push {filepath}")
            push_files.append(filepath)
        else:
            warn(f"could not find source for {filepath}")

    if prune:
        for filepath in sorted(filelist):
            print(f"prune {filepath}")
            prune_files.append(filepath)

    if len(push_files) == 0 and len(prune_files) == 0:
        return # nothing to do
    if dry_run:
        return
    if not (yes or confirm('Proceed [Y/n]? ', True)):
        sys.exit(2)
    backend.push(context.root, push_files, prune_files)

#-----------------------------------------------------------------------------
# Command: info
#-----------------------------------------------------------------------------

@main.command()
@click.pass_obj
def info(context):
    """Print statistics about the music library."""
    manifest = context.load_manifest()

    click.echo('Groups:')
    total = 0
    for group in manifest.groups():
        group_total = len(group)
        click.echo(f'  {group.id}: {group_total} songs')
        total += group_total
    click.echo(f'Total: {total} songs')

#-----------------------------------------------------------------------------
# Command: dump
#-----------------------------------------------------------------------------

@main.command()
@click.pass_obj
def dump(context):
    """Dump the manifest to stdout.

    This is mainly useful for debugging.
    """
    manifest = context.load_manifest()
    write_manifest(manifest, sys.stdout)

#-----------------------------------------------------------------------------
# Command: tag
#-----------------------------------------------------------------------------

@main.command()
@click.argument('input')
@click.argument('output')
@click.argument('title')
@click.argument('artist')
@click.argument('album')
def tag(input, output, title, artist, album):
    """Tag a music file using ffmpeg."""
    try:
        Tags(title, artist, album).apply(input, output)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

#-----------------------------------------------------------------------------
# Command: taghash
#-----------------------------------------------------------------------------

@main.command()
@click.argument('title')
@click.argument('artist')
@click.argument('album')
def taghash(title, artist, album):
    """Calculate a tag hash from tag values."""
    click.echo('%08x' % Tags(title, artist, album).hash())

#-----------------------------------------------------------------------------

if __name__ == '__main__':
    main()

# vim:tw=78
