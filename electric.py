#!/usr/bin/env python3
########################################
# Electric music library manager
#---------------------------------------
#
#   Author: Daniel Li
#   Date: Sep 04 2024
#
#   Dependencies:
#     - python
#     - ffmpeg: for update command
#     - adb: for adb backend
#
########################################

import argparse
import datetime
import hashlib
import os
import re
import shutil
import subprocess
import sys
import zlib

DEFAULT_ROOT = os.path.dirname(os.path.realpath(__file__))

# The list of valid groups. These should match the order in the manifest.
GROUPS = [('core', 'Electric'), ('extra', 'Electric Extra')]

########################################
# Tag Overrides
########################################

# The artist name and song title are automatically generated by converting
# their respective identifiers to uppercase and replacing dashes with spaces.
# For the majority of cases, this works fabulously.
# There are of course a few exceptions.
# For those, we override the automatically generated tag values here.

ARTIST_NAME_OVERRIDES = {
    'a-39': 'A-39',
    'ex-lyd': 'EX-LYD'
}

SONG_TITLE_OVERRIDES = {
    ('au5', 'moonland-derpcat-remix'): 'MOONLAND (DERPCAT REMIX)',
    ('camellia', '1f1e33'): '#1F1E33'
}

########################################
# Utility Functions
########################################

stdout_istty = os.isatty(1)
stderr_istty = os.isatty(2)

_err_prefix = '\033[1;31merror:\033[0m' if stderr_istty else 'error:'
_warn_prefix = '\033[1;33mwarning:\033[0m' if stderr_istty else 'warning:'

def err(message):
    print(f"{_err_prefix} {message}", file=sys.stderr)

def warn(message):
    print(f"{_warn_prefix} {message}", file=sys.stderr)

# Ask the user for confirmation.
# If the response is empty (ie. the user simply pressed Enter),
# the specified default is returned if provided, otherwise False.
# If the response is 'Y' or 'y', returns True, otherwise returns False.
def confirm(prompt, default=False):
    reply = input(prompt)
    return default if len(reply) == 0 else reply == 'y' or reply == 'Y'

# Calculate the MD5 hash of a file and return it as a hex string.
# See https://stackoverflow.com/a/59056837
def get_file_hash(filename):
    with open(filename, 'rb') as file:
        md5 = hashlib.md5()
        while chunk := file.read(65536):
            md5.update(chunk)
    return md5.hexdigest()

class Tags:
    def __init__(self, title, artist, album):
        self.title = title
        self.artist = artist
        self.album = album

    # Calculate the tag hash. Returns a 32-bit integer.
    def hash(self):
        return 0xffffffff & zlib.crc32(
            self.title.encode('utf-8') +
            self.artist.encode('utf-8') +
            self.album.encode('utf-8'))

    # Apply tags to the specified input_file and write to output_file.
    def apply(self, input_file, output_file):
        subprocess.run([
            'ffmpeg', '-y', '-hide_banner', '-loglevel', 'warning',
            '-i', input_file,
            '-codec', 'copy',
            '-map', '0:a',
            '-map_metadata', '-1',
            '-metadata', 'title=' + self.title,
            '-metadata', 'artist=' + self.artist,
            '-metadata', 'album=' + self.album,
            '-bitexact',
            '-f', 'mp3', output_file], check=True)

########################################
# Manifest
########################################

class Manifest:
    def __init__(self):
        self._groups = {groupid: Group(groupid, album) for groupid, album in GROUPS}

    def group(self, groupid):
        return self._groups[groupid]

    def groups(self):
        # cross our fingers for insertion order
        return self._groups.values()

    def __contains__(self, groupid):
        return groupid in self._groups

    def songs(self):
        return (song for group in self.groups() for song in group.songs())

class Group:
    def __init__(self, id, album):
        self.id = id
        self.album = album
        self._songs = {}

    def songs_unsorted(self):
        return self._songs.values()

    def songs(self):
        return sorted(self._songs.values(), key=lambda song: song.baseid)

    def __contains__(self, baseid):
        return baseid in self._songs

    def __len__(self):
        return len(self._songs)

    def add(self, song):
        self._songs[song.baseid] = song

class Song:
    def __init__(self, group, artist, title, date, file_hash, tag_hash):
        self.group = group
        self.artist = artist
        self.title = title
        self.date = date
        self.file_hash = file_hash
        self.tag_hash = tag_hash

    @property
    def groupid(self):
        return self.group.id

    @property
    def baseid(self):
        return (self.artist, self.title)

    @property
    def fullid(self):
        return (self.groupid, self.artist, self.title)

    def __str__(self):
        return f'{self.groupid}/{self.artist}.{self.title}'

    def tags(self):
        return Tags(
            (SONG_TITLE_OVERRIDES[self.baseid] if self.baseid in SONG_TITLE_OVERRIDES
                else self.title.upper().replace('-', ' ')),
            (ARTIST_NAME_OVERRIDES[self.artist] if self.artist in ARTIST_NAME_OVERRIDES
                else self.artist.upper().replace('-', ' ')),
            self.group.album)

    def filename(self):
        assert self.file_hash is not None
        return f'{self.artist}.{self.title}.{self.file_hash}.mp3'

    def filepath(self):
        return f'{self.groupid}/{self.filename()}'

class ManifestParseError(Exception):
    pass

# regex for group header
RE_GROUP_HEADER = re.compile('\\[([a-z]+)\\]')
# regex for artist and title fields
RE_IDENT = re.compile('[0-9a-z]+(?:-[0-9a-z]+)*')
# regex for date field
RE_DATE = re.compile('([0-9]{4})-([0-9]{2})-([0-9]{2})')
# regex for file_hash field
RE_FILE_HASH = re.compile('[0-9a-f]{32}')
# regex for tag_hash field
RE_TAG_HASH = re.compile('[0-9a-f]{8}')

# Reads the manifest from a file object.
def read_manifest(file):
    manifest = Manifest()

    line_num = 0
    current_group = None

    for line in file:
        # increment line number before the loop to catch continue
        line_num += 1
        # remove trailing newline
        line = line[:-1]

        match = RE_GROUP_HEADER.fullmatch(line)
        if match:
            groupid = match.group(1)
            if groupid not in manifest:
                raise ManifestParseError(f"Invalid group '{groupid}' at line {line_num}")
            current_group = manifest.group(groupid)
            continue

        if current_group is None:
            raise ManifestParseError(f"Group header required before line {line_num}")

        fields = line.split(' ')
        if len(fields) != 5:
            raise ManifestParseError(f"Incorrect number of fields at line {line_num}")

        artist = fields[0]
        if not RE_IDENT.fullmatch(artist):
            raise ManifestParseError(f"Invalid artist '{artist}' at line {line_num}")

        title = fields[1]
        if not RE_IDENT.fullmatch(title):
            raise ManifestParseError(f"Invalid title '{title}' at line {line_num}")

        if (artist, title) in current_group:
            raise ManifestParseError(f"Duplicate song '{artist}.{title}' at line {line_num}")

        date_str = fields[2]
        match = RE_DATE.fullmatch(date_str)
        if not match:
            raise ManifestParseError(f"Invalid date '{date_str}' at line {line_num}")
        date = datetime.date(int(match.group(1)), int(match.group(2)), int(match.group(3)))

        file_hash_str = fields[3]
        if not RE_FILE_HASH.fullmatch(file_hash_str):
            raise ManifestParseError(f"Invalid file hash '{file_hash_str}' at line {line_num}")
        file_hash = file_hash_str

        tag_hash_str = fields[4]
        if not RE_TAG_HASH.fullmatch(tag_hash_str):
            raise ManifestParseError(f"Invalid tag hash '{tag_hash_str}' at line {line_num}")
        tag_hash = int(tag_hash_str, 16)

        current_group.add(Song(current_group, artist, title, date, file_hash, tag_hash))

    return manifest

# Load the manifest from a file by name.
def load_manifest(filename):
    with open(filename, 'r') as file:
        return read_manifest(file)

# Load the manifest from a file by name and terminate on failure.
def load_manifest_or_abort(filename):
    try:
        return load_manifest(filename)
    except OSError as e:
        err(f"failed to load '{filename}': {e.strerror}")
        sys.exit(1)
    except ManifestParseError as e:
        err(f"failed to parse '{filename}': {e}")
        sys.exit(1)

# Write the manifest to a file object.
def write_manifest(file, manifest):
    for group in manifest.groups():
        file.write(f'[{group.id}]\n')
        for song in group.songs():
            artist = song.artist
            title = song.title
            date = song.date.strftime("%Y-%m-%d")
            file_hash = song.file_hash
            tag_hash = '%08x' % song.tag_hash
            file.write(f'{artist} {title} {date} {file_hash} {tag_hash}\n')

# Save the manifest to a file by name.
def save_manifest(filename, manifest):
    with open(filename, 'w') as file:
        write_manifest(file, manifest)

# Save the manifest to a file by name and terminate on failure.
def save_manifest_or_abort(filename, manifest):
    try:
        save_manifest(filename, manifest)
    except OSError as e:
        err(f"failed to save '{filename}': {e.strerror}")
        sys.exit(1)

########################################
# Command Line Parsing
########################################

class Context:
    def __init__(self, root, manifest_file):
        self.root = root
        self.manifest_file = manifest_file

    def load_manifest(self):
        return load_manifest_or_abort(self.manifest_file)

    def save_manifest(self, manifest):
        save_manifest_or_abort(self.manifest_file, manifest)

def main():
    # Get colors working!
    # See https://stackoverflow.com/a/293633
    if sys.platform == 'win32':
        os.system('')

    args = parser.parse_args()
    root = args.root
    manifest_file = args.manifest if args.manifest is not None else os.path.join(root, 'manifest.txt')
    context = Context(root, manifest_file)

    if args.func is None:
        parser.print_help()
        sys.exit(2)

    args.func(context, args)

parser = argparse.ArgumentParser(
        prog='electric',
        description='The Electric music library manager.')
parser.add_argument('-r', '--root', metavar='DIR', default=DEFAULT_ROOT, help=f'root directory (default: {DEFAULT_ROOT})')
parser.add_argument('--manifest', metavar='FILE', help=f'manifest file (default: <root>{os.path.sep}manifest.txt)')
parser.set_defaults(func=None)
commands = parser.add_subparsers(metavar='command')

#---------------------------------------
# Command: update
#---------------------------------------

RE_IMPORT_FILE = re.compile('([a-z]+)\\.([0-9a-z]+(?:-[0-9a-z]+)*)\\.([0-9a-z]+(?:-[0-9a-z]+)*)\\.mp3')

class UpdateItem:
    def __init__(self, song, tags, source_file):
        self.song = song
        self.tags = tags
        self.source_file = source_file

class ImportItem(UpdateItem):
    def log(self):
        print(f'Importing {self.song}')

class RetagItem(UpdateItem):
    def log(self):
        print(f'Retagging {self.song}')

def command_update(context, args):
    queue_dir = os.path.join(context.root, 'queue')
    manifest = context.load_manifest()

    items = []

    # go through queue and add files to import
    for filename in os.listdir(queue_dir):
        match = RE_IMPORT_FILE.fullmatch(filename)
        if not match:
            continue

        groupid = match.group(1)
        if groupid not in manifest:
            warn(f"{filename}: invalid group '{groupid}'")
            continue

        group = manifest.group(groupid)
        artist = match.group(2)
        title = match.group(3)
        if (artist, title) in group:
            warn(f"{filename}: song already exists")
            continue

        date = datetime.date.today()
        song = Song(group, artist, title, date, None, None)
        tags = song.tags()
        print(f"\033[1;32mimport:\033[0m {song}")
        print(f"  title: {tags.title}")
        print(f"  artist: {tags.artist}")
        print(f"  album: {tags.album}")
        items.append(ImportItem(song, tags, os.path.join(queue_dir, filename)))

    # search for incorrectly tagged files in manifest
    for song in manifest.songs():
        tags = song.tags()
        if song.tag_hash == tags.hash():
            continue # tags are correct

        print(f"\033[1;36mretag:\033[0m {song}")
        print(f"  title: {tags.title}")
        print(f"  artist: {tags.artist}")
        print(f"  album: {tags.album}")
        items.append(RetagItem(song, tags, os.path.join(context.root, song.filepath())))

    if len(items) == 0:
        return

    if not confirm('Proceed [Y/n]? ', True):
        sys.exit(2)

    # process update items
    for item in items:
        item.log()

        temp_file = item.source_file + '~'
        try:
            os.remove(temp_file)
        except FileNotFoundError:
            pass
        item.tags.apply(item.source_file, temp_file)

        item.song.file_hash = get_file_hash(temp_file)
        item.song.tag_hash = item.tags.hash()
        dest_file = os.path.join(context.root, item.song.filepath())
        os.replace(temp_file, dest_file)

    # save the manifest
    context.save_manifest()

    # now it should be safe to cleanup
    for item in items:
        os.remove(item.source_file)

command = commands.add_parser(
    'update',
    help='import new music and fix tags',
    description='Import new music and fix tags.')
command.set_defaults(func=command_update)

#---------------------------------------
# Command: maint
#---------------------------------------

def command_maint(context, args):
    prune = args.prune
    verify = args.verify
    dry = args.dry_run
    interactive = not args.yes

    manifest = context.load_manifest()
    ok = True
    orphans = []

    for group in manifest.groups():
        try:
            filenames = set([file for file in os.listdir(os.path.join(context.root, group.id)) if not file.startswith('.') and file.endswith('.mp3')])
        except FileNotFoundError:
            filenames = set()
        for song in group.songs():
            filename = song.filename()
            if filename not in filenames:
                warn(f'missing file: {group.id}/{filename}')
                ok = False
                continue

            filenames.remove(filename)
            if not verify:
                continue

            filename = os.path.join(context.root, song.filepath())
            try:
                file_hash = get_file_hash(filename)
            except OSError as e:
                err(f"{song}: failed to get file hash: {e.strerror}")
                ok = False
                continue

            if file_hash != song.file_hash:
                warn(f"{song}: hashes differ")
                ok = False

        for filename in sorted(filenames):
            orphans.append(os.path.join(group.id, filename))

    for filename in orphans:
        warn(f'orphan: {filename}')
        if prune and not dry and (not interactive or confirm('Delete [Y/n]? ', True)):
            os.remove(os.path.join(context.root, filename))
        else:
            ok = False

    if not ok:
        sys.exit(2)

command = commands.add_parser(
    'maint',
    help='check and manage the music directory',
    description='Check and manage the music directory.')
command.add_argument('--prune', action='store_true', help='delete extraneous files')
command.add_argument('--verify', action='store_true', help='verify file integrity')
command.add_argument('-n', '--dry-run', action='store_true', help='don\'t do anything, only show what would happen')
command.add_argument('-y', '--yes', action='store_true', help='do not prompt for confirmation')
command.set_defaults(func=command_maint)

#---------------------------------------
# Command: pull
#---------------------------------------

def command_pull(context, args):
    raise NotImplementedError()

command = commands.add_parser(
    'pull',
    help='satisfy manifest using files from source directories',
    description='Satisfy the manifest using files from one or more source directories.')
command.add_argument('-n', '--dry-run', action='store_true', help='don\'t do anything, only show what would happen')
command.add_argument('source', nargs='+', help='source directories')
command.set_defaults(func=command_pull)

#---------------------------------------
# Command: push
#---------------------------------------

class FilePushBackend:
    def __init__(self, target_dir):
        self.target_dir = target_dir

    def get_file_list(self):
        return {group.id: set(file for file in os.listdir(os.path.join(target_dir, group.id))
                                   if not file.startswith('.') and file.endswith('.mp3'))
                for group in manifest.groups()}

    def push(self, source_dir, push_files, prune_files):
        for filepath in push_files:
            print(f"Copying {filepath}")
            source_file = os.path.join(source_dir, filepath)
            target_file = os.path.join(target_dir, filepath)
            with open(source_file, 'rb') as source, open(target_file, 'xb') as target:
                shutil.copyfileobj(source, target)
        for filepath in prune_files:
            print(f"Removing {filepath}")
            os.remove(os.path.join(target_dir, filepath))

class AdbPushBackend:
    def __init__(self, target_dir):
        self.target_dir = target_dir

    def _get_group_file_list(self, group):
        group_dir = f'{self.target_dir}/{group.id}'

        # get a file list for the target group directory
        result = subprocess.run(
            ['adb', 'shell', f'ls \'{group_dir}\''],
            stdout=subprocess.PIPE,
            text=True)

        if result.returncode != 0:
            warn(f"failed to get file list for '{group_dir}', perhaps it doesn't exist")
            return None

        return set(line for line in result.stdout.splitlines() if line.endswith('.mp3'))

    def get_file_list(self, manifest):
        return {group.id: self._get_group_file_list(group) for group in manifest.groups()}

    def push(self, root, push_files, prune_files):
        for filepath in push_files:
            source_file = os.path.join(root, filepath)
            target_file = f'{self.target_dir}/{filepath}'

            print(f"Copying {filepath}")
            result = subprocess.run(['adb', 'push', source_file, target_file])
            if result.returncode != 0:
                err(f"adb failed")
                return False

        if len(prune_files) > 0:
            result = subprocess.run(['adb', 'shell', f"cd '{self.target_dir}' && rm -f {' '.join(prune_files)}"])
            if result.returncode != 0:
                err(f"adb failed")
                return False

        return True

def command_push(context, args):
    backend_name = args.backend
    dry = args.dry_run
    interactive = not args.yes
    target = args.target

    match backend_name:
        case 'file':
            if len(target) != 1:
                err('file backend requires 1 argument')
                sys.exit(1)
            backend = FilePushBackend(target[0])
        case 'adb':
            match len(target):
                case 0:
                    target_dir = '/storage/self/primary/Music'
                case 1:
                    target_dir = target[0]
                case _:
                    err('adb backend requires 0-1 arguments')
                    sys.exit(1)
            backend = AdbPushBackend(target_dir)
        case _:
            err(f"unrecognized backend '{backend_name}'")
            sys.exit(1)

    manifest = context.load_manifest()
    file_list = backend.get_file_list(manifest)
    push_files = []
    prune_files = []

    for group in manifest.groups():
        group_file_list = file_list[group.id]

        if group_file_list is None:
            continue

        for song in group.songs():
            filename = song.filename()
            if filename in group_file_list:
                group_file_list.remove(filename)
                continue

            # check if source directory has the file
            filepath = song.filepath()
            source_file = os.path.join(context.root, filepath)
            if os.path.exists(source_file):
                print(f"push {filepath}")
                push_files.append(filepath)
            else:
                warn(f"could not find source for {filepath}")

        for filename in sorted(group_file_list):
            filepath = os.path.join(group.id, filename)
            print(f"prune {filepath}")
            prune_files.append(filepath)

    if len(push_files) == 0 and len(prune_files) == 0:
        return # nothing to do
    if dry:
        return
    if interactive and not confirm('Proceed [Y/n]? ', True):
        sys.exit(2)
    if not backend.push(context.root, push_files, prune_files):
        sys.exit(1)

command = commands.add_parser(
    'push',
    help='copy files to destination using local manifest',
    description='Copy files to destination using local manifest.')
command.add_argument('-b', '--backend', default='file', help='backend to use')
command.add_argument('-n', '--dry-run', action='store_true', help='don\'t do anything, only show what would happen')
command.add_argument('-y', '--yes', action='store_true', help='don\'t prompt for confirmation')
command.add_argument('target', nargs='*', help='target directory')
command.set_defaults(func=command_push)

#---------------------------------------
# Command: info
#---------------------------------------

def command_info(context, args):
    print(f'Root: {context.root}')
    print(f'Manifest: {context.manifest_file}')
    manifest = context.load_manifest()

    print('Groups:')
    total = 0
    for group in manifest.groups():
        group_total = len(group)
        print(f'  {group.id}: {group_total} songs')
        total += group_total
    print(f'Total: {total} songs')

command = commands.add_parser(
    'info',
    help='print info about the manifest',
    description='Print information about the manifest.')
command.set_defaults(func=command_info)

#---------------------------------------
# Command: dump
#---------------------------------------

def command_dump(context, args):
    manifest = context.load_manifest()
    write_manifest(sys.stdout, manifest)

command = commands.add_parser(
    'dump',
    help='dump the manifest to stdout',
    description='Dump the manifest to stdout. This is useful for debugging.')
command.set_defaults(func=command_dump)

#---------------------------------------
# Command: tag
#---------------------------------------

def command_tag(context, args):
    try:
        Tags(args.title, args.artist, args.album).apply(args.input, args.output)
    except subprocess.CalledProcessError as e:
        err(f"ffmpeg failed: {e}")
        sys.exit(e.returncode)

command = commands.add_parser(
    'tag',
    description='Tag a music file.')
command.add_argument('input', help='input file')
command.add_argument('output', help='output file')
command.add_argument('title', help='title')
command.add_argument('artist', help='artist')
command.add_argument('album', help='album')
command.set_defaults(func=command_tag)

#---------------------------------------
# Command: taghash
#---------------------------------------

def command_taghash(context, args):
    import json
    data = json.loads(subprocess.check_output([
        'ffprobe', '-hide_banner', '-loglevel', 'warning',
        '-output_format', 'json', '-show_entries', 'format_tags',
        args.file]))['format']['tags']
    tag_hash = Tags(data['title'], data['artist'], data['album']).hash()
    print('%08x' % tag_hash)

command = commands.add_parser(
    'taghash',
    description='Print the tag hash of a file (currently very slow!). Only used for debugging.')
command.add_argument('file', help='music file')
command.set_defaults(func=command_taghash)

#---------------------------------------

main()
