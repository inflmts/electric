#!/usr/bin/env python3
##############################################################################
#
#         ,/
#       ,'/
#     ,' /___,  888888 88     888888  dP""b8 888888 88""Yb 88  dP""b8
#   .'__   ,'   88__   88     88__   dP   `"   88   88__dP 88 dP   `"
#      / ,'     88""   88  .o 88""   Yb        88   88"Yb  88 Yb
#     /,'       888888 88ood8 888888  YboodP   88   88  Yb 88  YboodP
#    /'
#
# ----------------------------------------------------------------------------
#                           Music Library Manager
# ----------------------------------------------------------------------------
#
#   Copyright (c) 2024-2025 Daniel Li
#
#   This software is available under the MIT License.
#
#   Dependencies:
#     - python 3.8
#     - click
#     - ffmpeg (optional): for import recoding
#     - adb (optional): for adb backend
#
##############################################################################

import click
from collections import Counter, namedtuple
import datetime
import hashlib
import itertools
import operator
import os
import re
import shlex
import shutil
import subprocess
import sys
import tempfile
import zlib

# output newline on all platforms
sys.stdout.reconfigure(newline='\n')

default_root = os.path.dirname(os.path.realpath(__file__))

# The list of valid groups.
GROUPS = ('core', 'extra')

song_file_regex = re.compile(r'[0-9a-z\.-]*\.[0-9a-f]{16}\.mp3')
id_regex = re.compile(r'[1-9][0-9]*')
artist_regex = re.compile(r'[0-9a-z]+(?:-[0-9a-z]+)*')
title_regex = artist_regex
date_regex = re.compile(r'([0-9]{4})-([0-9]{2})-([0-9]{2})')
mhash_regex = re.compile(r'[0-9a-f]{64}')
import_file_regex = re.compile(r'([a-z]+)\.([0-9a-z]+(?:-[0-9a-z]+)*)\.([0-9a-z]+(?:-[0-9a-z]+)*)\.mp3')
replace_file_regex = re.compile(r'\+(\d+)\.mp3')

##############################################################################
# Utility Functions
##############################################################################

def err(message):
    sys.stderr.write(f'\033[1;31merror:\033[0m {message}\n')

def warn(message):
    sys.stderr.write(f'\033[1;33mwarning:\033[0m {message}\n')

def msg(message):
    sys.stderr.write(f'{message}\n')

def confirm(prompt, default=False):
    """Prompt the user for confirmation.

    If the response is empty (ie. the user simply pressed Enter),
    the specified default is returned if provided, otherwise False.
    If the response is 'Y' or 'y', returns True, otherwise returns False.
    """
    reply = input(prompt)
    return default if len(reply) == 0 else reply == 'y' or reply == 'Y'

def safe_rename(src, dest):
    # not actually safe
    if os.path.exists(dest):
        raise FileExistsError(dest)
    os.rename(src, dest)

##############################################################################
# Tags
##############################################################################

class MP3Error(Exception):
    pass

id3_header = b'ID3\x04\x00\x00\x00\x00\x01\x76'
mp3_bitrate_table = [None, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, None]
mp3_frequency_table = [44100, 48000, 32000, None]

def id3_encode_uint28(x):
    return bytes((x >> 21 & 0x7f, x >> 14 & 0x7f, x >> 7 & 0x7f, x & 0x7f))

def id3_encode_frame(id, content):
    return id + id3_encode_uint28(len(content)) + b'\x00\x00' + content

def id3_encode_text(id, content):
    return id3_encode_frame(id, b'\x03' + content.encode('utf-8') + b'\x00')

def id3_encode(tags):
    """Encode song tags as a 256-byte ID3v2.4.0 header."""
    data = (id3_header
        + id3_encode_text(b'TIT2', tags.title)
        + id3_encode_text(b'TPE1', tags.artist)
        + id3_encode_text(b'TALB', tags.album))
    if len(data) > 256:
        raise ValueError('ID3 tag exceeds 256 bytes')
    data = data.ljust(256, b'\x00')
    assert len(data) == 256
    return data

def id3_decode_int28(b):
    return (b[0] & 0x7f) << 21 | (b[1] & 0x7f) << 14 | (b[2] & 0x7f) << 7 | (b[3] & 0x7f)

def id3_skip(f):
    """Skip the ID3 header in a seekable readable stream."""
    header = f.peek(10)
    if header[0:3] != b'ID3':
        return
    if header[5] != 0:
        raise MP3Error(f'id3: unrecognized flags ({header[5]:8b})')
    size = id3_decode_int28(header[6:10])
    f.seek(10 + size, os.SEEK_CUR)

#def mp3_read_frame(f):
#    """Read an MP3 frame."""
#    header = f.read(4)
#    if not header:
#        return None
#    b0, b1, b2, b3 = header
#    if b0 != 0b11111111 or b1 & 0b11111110 != 0b11111010:
#        raise Exception('Unrecognized frame header')
#    bitrate = mp3_bitrate_table[b2 >> 4 & 0b1111]
#    if bitrate is None:
#        raise Exception('Invalid bitrate index')
#    freq = mp3_frequency_table[b2 >> 2 & 0b11]
#    if freq is None:
#        raise Exception('Invalid frequency index')
#    padding = b2 >> 1 & 0b1
#    if b2 & 0b1:
#        raise Exception('Private bit set')
#    if b3 & 0b11:
#        raise Exception('Emphasis bit set')
#    size = 144000 * bitrate // freq + padding
#    return header + read_exact(f, size - 4)

def mp3_import(srcf, destf, tdata):
    sha256 = hashlib.sha256()
    id3_skip(srcf)
    if destf is not None:
        destf.write(tdata)
    header = srcf.peek(4)
    if len(header) < 4:
        raise MP3Error('mp3: unexpected end of file')
    if header[0] != 0xff or header[1] & 0xfe != 0xfa:
        raise MP3Error('mp3: invalid magic')
    while chunk := srcf.read(65536):
        sha256.update(chunk)
        if destf is not None:
            destf.write(chunk)
    return sha256.hexdigest()

##############################################################################
# Songs
##############################################################################

SongTags = namedtuple('SongTags', ('title', 'artist', 'album'))

class Song:
    """
    Represents a song in the catalog.

    All attributes are readonly except for `mhash`. Note that changing `mhash`
    will cause the computed path to change as well. `mhash` may be None, which
    indicates that the song does not have an associated file; this could mean
    that the song is currently being imported.
    """

    def __init__(self, id, group, artist, title, date, mhash):
        self.id = id
        self.group = group
        self.artist = artist
        self.title = title
        self.date = date
        self.mhash = mhash

        # The artist name and song title are generated by converting their
        # respective identifiers to uppercase and replacing dashes with
        # spaces. For the vast majority of cases, this works fabulously.
        self.tags = SongTags(
            title.upper().replace('-', ' '),
            artist.upper().replace('-', ' '),
            self.eid)
        self.tdata = id3_encode(self.tags)
        self.thash = '%04x' % (zlib.crc32(self.tdata) >> 16 & 0xffff)

    def __str__(self):
        return f'{self.eid}[{self.group}.{self.artist}.{self.title}]'

    @property
    def eid(self):
        return f'E{self.id:04}'

    @property
    def mabbrev(self):
        if self.mhash is None:
            raise TypeError(f'Song {self} does not have a mhash')
        return self.mhash[:12]

    @property
    def path(self):
        return f'{self.group}/{self.artist}.{self.title}.{self.mabbrev}{self.thash}.mp3'

    def write(self, f):
        id = self.id
        group = self.group
        artist = self.artist
        title = self.title
        date = self.date.strftime('%Y-%m-%d')
        mhash = '-' if self.mhash is None else self.mhash
        f.write(f'{id} {group} {artist} {title} {date} {mhash}\n')

##############################################################################
# Catalog
##############################################################################

class CatalogError(Exception):
    pass

class Catalog:
    def __init__(self, file=None):
        self.file = file
        self._songs = []

    def __len__(self):
        return len(self._songs)

    def __getitem__(self, id):
        return self._songs[id - 1]

    def __iter__(self):
        return iter(self._songs)

    def __reversed__(self):
        return reversed(self._songs)

    def __contains__(self, id):
        return id >= 1 and id <= len(self._songs)

    @property
    def nextid(self):
        return len(self._songs) + 1

    def add(self, id, group, artist, title, date, mhash):
        if id != self.nextid:
            raise CatalogError(f'attempted to add id {id}, expected {self.nextid}')
        song = Song(id, group, artist, title, date, mhash)
        self._songs.append(song)
        return song

    def register(self, group, artist, title, mhash):
        date = datetime.date.today()
        return self.add(self.nextid, group, artist, title, date, mhash)

    def write(self, f):
        """Write the catalog to a file object."""
        for song in self:
            song.write(f)

    def save(self):
        if self.file is None:
            raise TypeError('Catalog has no file')
        tmpfile = self.file + '.lock'
        tmpf = open(tmpfile, 'x', newline='\n')
        try:
            with tmpf:
                self.write(tmpf)
        except:
            os.remove(tmpfile)
            raise
        os.replace(tmpfile, self.file)


def read_catalog(f, file=None):
    """Read the catalog from a file object."""

    catalog = Catalog(file)
    lineno = 0

    def fail(message):
        raise CatalogError(f'line {lineno}: {message}')

    for line in f:
        # increment line number before the loop to catch continue
        lineno += 1
        # remove trailing newline
        line = line[:-1]

        fields = line.split(' ')
        if len(fields) != 6:
            fail(f'Expected 6 fields but {len(fields)} present')
        id, group, artist, title, date, mhash = fields

        if not id_regex.fullmatch(id):
            fail(f'Invalid id {id!r}')
        id = int(id)

        if group not in GROUPS:
            fail(f'Invalid group {group!r}')

        if not artist_regex.fullmatch(artist):
            fail(f'Invalid artist {artist!r}')

        if not title_regex.fullmatch(title):
            fail(f'Invalid title {title!r}')

        if not (match := date_regex.fullmatch(date)):
            fail(f'Invalid date {date!r}')
        y, m, d = match.groups()
        date = datetime.date(int(y), int(m), int(d))

        if not mhash_regex.fullmatch(mhash):
            fail(f'Invalid mhash {mhash!r}')

        try:
            catalog.add(id, group, artist, title, date, mhash)
        except CatalogError as e:
            fail(e)

    return catalog

class File:
    def __init__(self, path):
        # `path` MUST be a valid path
        self.path = path
        self.mabbrev = path[-20:-8]
        self.thash = path[-8:-4]
        self.preserve = False # currently not used

def get_update_operations(catalog, paths, source=None, allow_retag=True):
    """
    Determine the operations required to satisfy the catalog given an iterable
    of existing paths and an optional external source to retrieve missing
    files from. Returns a tuple of three lists:

        transfers: list of (src, dest) or None if no `source` was provided
        renames: list of (src, dest, tdata), tdata may be None
        prunes: list of paths to delete
    """

    files = {path: File(path) for path in paths}

    # find songs without a file
    missing = []
    for song in catalog:
        # ignore songs without an associated file
        if song.mhash is None:
            continue
        file = files.pop(song.path, None)
        if file is None:
            missing.append(song)

    # find files that can be renamed/retagged
    transfers = [] if source is not None else None
    renames = []
    for song in missing:
        for file in files.values():
            if file.mabbrev != song.mabbrev:
                continue
            retag = song.thash != file.thash
            if retag and not allow_retag:
                continue
            del files[file.path]
            msg(f'\033[1;36m** {"retag" if retag else "rename"}:\033[0m {song}')
            renames.append((file.path, song.path, song.tdata if retag else None))
            break
        else:
            if source is not None:
                for path in source:
                    if path == song.path:
                        msg(f'\033[1;36m** transfer:\033[0m {song}')
                        transfers.append((path, song.path))
                        break
                else:
                    warn(f'unable to find source for {song}')
            else:
                warn(f'unable to find source for {song}')

    # find files to prune
    prunes = []
    for file in files.values():
        if not file.preserve:
            if prune:
                msg(f'\033[1;31prune:\033[0m {file.path}')
                prunes.append(file.path)
            else:
                warn(f'orphan: {file.path}')

    return transfers, renames, prunes

def list_local(root):
    paths = []
    for group in GROUPS:
        for file in os.listdir(os.path.join(root, group)):
            file = os.path.normcase(file)
            path = f'{group}/{file}'
            if song_file_regex.fullmatch(file):
                paths.append(path)
            elif file != 'folder.jpg':
                warn(f'ignoring file {path!r}')
    return paths

def write_tdata(file, tdata):
    assert len(tdata) == 256
    with open(file, 'r+b') as f:
        if f.read(10) != id3_header:
            raise Exception('Invalid ID3 header')
        assert f.tell() == 10
        f.write(tdata[10:])

def execute_local_operations(root, renames, prunes):
    # process renames/retags
    for src, dest, tdata in renames:
        msg(f'Renaming {src} -> {dest}')
        srcfile = os.path.join(root, src)
        destfile = os.path.join(root, dest)
        if tdata is not None:
            write_tdata(srcfile, tdata)
        safe_rename(srcfile, destfile)

    # process prunes
    for path in prunes:
        msg(f'Removing {path}')
        os.remove(os.path.join(root, path))

##############################################################################
# Import
##############################################################################

def interactive_import_file(root, catalog, queue_dir, file):
    while True:
        sys.stderr.write(f'\033[1m{file}:\033[0m ')
        args = input().split()
        if not args:
            err('no arguments specified')
            continue
        group = None
        if args[0] == 'c':
            group = 'core'
        elif args[0] == 'e':
            group = 'extra'
        if group is not None:
            if len(args) != 3:
                err('usage: c|e <artist> <title>')
                continue
            _, artist, title = args
            if not artist_regex.fullmatch(artist):
                err(f'invalid artist {artist!r}')
                continue
            if not title_regex.fullmatch(title):
                err(f'invalid title {title!r}')
                continue
            song = catalog.register(group, artist, title, None)
            commit_message = f'catalog: add {song.id}'
            break
        if args[0] == 's':
            return
        err(f'unrecognized command {args[0]!r}')

    msg(f'Importing {song}')
    srcfile = os.path.join(queue_dir, file)
    group_dir = os.path.join(root, song.group)

    recfd, recfile = tempfile.mkstemp(suffix='.mp3~', prefix='recode-', dir=group_dir)
    recf = open(recfd, 'rb')
    try:
        # recode using ffmpeg
        subprocess.run(
            ['ffmpeg', '-y',
             '-hide_banner',
             '-loglevel', 'warning',
             '-stats',
             '-i', srcfile,
             '-f', 'mp3',
             '-c', 'libmp3lame',
             '-id3v2_version', '0',
             recfile],
            check=True)

        tmpfd, tmpfile = tempfile.mkstemp(suffix='.mp3~', prefix='import-', dir=group_dir)
        tmpf = open(tmpfd, 'wb')
        try:
            # tag and calculate mhash
            mhash = mp3_import(recf, tmpf, song.tdata)
        except:
            tmpf.close()
            os.remove(tmpfile)
            raise
        tmpf.close()
        # the correct `destfile` is only known after calculating the mhash
        song.mhash = mhash
        destfile = os.path.join(root, song.path)
        try:
            safe_rename(tmpfile, destfile)
        except:
            os.remove(tmpfile)
            raise
    finally:
        recf.close()
        os.remove(recfile)

    # save catalog
    catalog.save()

    # cleanup
    os.remove(srcfile)

    # commit
    subprocess.run(
        ['git', '-C', root, 'commit',
         '-q', '-m', commit_message, 'catalog.txt'],
        check=True)

def interactive_import(root, catalog, queue_dir):
    """
    Scan the queue directory for files to import/replace existing
    songs with.
    """

    # sort by modification time, oldest first
    files = os.listdir(queue_dir)
    if not files:
        return
    files.sort(key=lambda file: os.stat(os.path.join(queue_dir, file)).st_mtime_ns)

    msg('\033[1mElectric Interactive Import\033[0m')
    sys.stderr.write('''\

  Import: c|e <artist> <title>
  Replace: r <id>
  Skip: s

''')
    for file in files:
        interactive_import_file(root, catalog, queue_dir, file)

##############################################################################
# Backends
##############################################################################

backends = {}

def backend(name):
    def decorator(cls):
        backends[name] = cls
        return cls
    return decorator

# Backends must implement these methods:
#
#   list()
#       Returns a list of paths in the backend.
#
#   push(root, transfers, renames, prunes)
#       Executes the specified updates on the remote.
#           - transfers: list of (src, dest) of files to push
#               - src: local source path
#               - dest: remote destination path
#           - renames: list of (src, dest, tdata) of files to rename
#               - src: remote source path
#               - dest: remote destination path
#               - tdata: None or the binary ID3 tags to write to the file
#           - prunes: list of paths to remove
#
#   pull(root, transfers)
#       Retrieves files from the remote.
#           - transfers: list of (src, dest) of files to pull
#               - src: remote source path
#               - dest: local destination path
#

@backend('file')
class FileBackend:
    def __init__(self, root):
        self.root = root

    @classmethod
    def create(cls, param):
        return cls(param)

    def list(self):
        return list_local(self.root)

    def push(self, root, transfers, renames, prunes):
        for src, dest in transfers:
            msg(f'Pushing {src} -> {dest}')
            srcfile = os.path.join(root, src)
            destfile = os.path.join(self.root, dest)
            shutil.copyfile(srcfile, destfile)
        execute_local_operations(self.root, renames, prunes)

    def pull(self, root, transfers):
        for src, dest in transfers:
            msg(f'Pulling {src} -> {dest}')
            srcfile = os.path.join(self.root, src)
            destfile = os.path.join(root, dest)
            shutil.copyfile(srcfile, destfile)

@backend('adb')
class AdbBackend:
    def __init__(self, root=None):
        self.root = root if root is not None else '/storage/emulated/0/Music'

    @classmethod
    def create(cls, param):
        return cls(param or None)

    def list(self):
        output = subprocess.run(
            ['adb', 'shell'],
            input=f'cd {shlex.quote(self.root)} && '
                  f'find {" ".join(GROUPS)} -mindepth 1 -maxdepth 1 -name "*.mp3"',
            stdout=subprocess.PIPE,
            text=True, check=True).stdout
        return [path for path in output.splitlines()
                     if song_file_regex.fullmatch(path.partition('/')[2])]

    def push(self, root, transfers, renames, prunes):
        for src, dest in transfers:
            msg(f'Pushing {src} -> {dest}')
            srcfile = os.path.join(root, src)
            subprocess.run(['adb', 'push', srcfile, f'{self.root}/{dest}'], check=True)

        commands = [f'set -eC\ncd {shlex.quote(self.root)}\n']
        for src, dest, tdata in renames:
            assert tdata is None
            commands.append(f'echo >&2 "Renaming {src} -> {dest}"\n')
            commands.append(f'mv -nT {src} {dest}\n')
        if prunes:
            commands.append(f'echo >&2 "Pruning {len(prunes)} files..."\n'
                            f'rm {" ".join(prunes)}\n')

        subprocess.run(
            ['adb', 'shell'],
            input=''.join(commands),
            text=True)

    def pull(self, root, transfers):
        for src, dest in transfers:
            msg(f'Pulling {src} -> {dest}')
            destfile = os.path.join(root, dest)
            subprocess.run(['adb', 'pull', src, destfile], check=True)

##############################################################################
# Command-Line Parsing
##############################################################################

class Context:
    def __init__(self, root):
        self.root = root
        self.catalog_file = os.path.join(root, 'catalog.txt')

    def load_catalog(self):
        with open(self.catalog_file) as f:
            try:
                return read_catalog(f, self.catalog_file)
            except CatalogError as e:
                err(f'catalog: {e}')
                sys.exit(1)

    def create_backend(self, param):
        name = 'file'
        mat = re.match(r'^[a-z]+:', param)
        if mat:
            name = param[:mat.end() - 1]
            param = param[mat.end():]
        cls = backends.get(name)
        if cls is None:
            err(f'unrecognized backend name {name!r}')
            sys.exit(1)
        return cls.create(param)

@click.group()
@click.option('-r', '--root', metavar='DIR', default=default_root, show_default=True, help='root directory')
@click.pass_context
def main(ctx, root):
    ctx.obj = Context(root)

#-----------------------------------------------------------------------------
# Command: update
#-----------------------------------------------------------------------------

@main.command()
@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
@click.option('--prune', is_flag=True, help='prune extraneous music files')
@click.option('--no-import', is_flag=True, help='do not import new songs')
@click.argument('remote', required=False)
@click.pass_obj
def update(context, dry_run, yes, prune, no_import, remote):
    """Update the music library.

    Rename, retag, and optionally pull files from a remote to match the
    catalog. In addition, look for files in the queue directory to to import
    as new songs or replace existing songs.
    """
    root = context.root
    catalog = context.load_catalog()

    if not no_import:
        interactive_import(root, catalog, os.path.join(root, 'queue'))

    files = list_local(root)
    if remote is not None:
        backend = context.create_backend(remote)
        remote_files = backend.list()
    else:
        remote_files = None

    transfers, renames, prunes = get_update_operations(catalog, files, source=remote_files)

    if dry_run or not (transfers or renames or prunes):
        return

    if not (yes or confirm('Proceed [Y/n]? ', True)):
        sys.exit(2)

    if transfers:
        backend.pull(transfers)
    execute_local_operations(root, renames, prunes)

#-----------------------------------------------------------------------------
# Command: push
#-----------------------------------------------------------------------------

@main.command()
@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
@click.option('--prune', is_flag=True, help='prune extraneous files')
@click.argument('remote')
@click.pass_obj
def push(context, dry_run, yes, prune, remote):
    """Send files to a remote."""
    root = context.root
    catalog = context.load_catalog()
    backend = context.create_backend(remote)

    local_files = list_local(root)
    remote_files = backend.list()
    transfers, renames, prunes = get_update_operations(catalog, remote_files, source=local_files)

    if dry_run or not (transfers or renames or prunes):
        return

    if not (yes or confirm('Proceed [Y/n]? ', True)):
        sys.exit(2)

    backend.push(root, transfers, renames, prunes)

#-----------------------------------------------------------------------------
# Command: info
#-----------------------------------------------------------------------------

@main.command()
@click.option('-l', '--latest', default=10, metavar='N', show_default=True, help='show N latest songs')
@click.option('-a', '--artists', default=0, metavar='N', help='show N most common artists')
@click.argument('songs', type=int, nargs=-1)
@click.pass_obj
def info(context, latest, artists, songs):
    """Print information about the catalog."""
    catalog = context.load_catalog()

    if songs:
        for id in songs:
            song = catalog.get(id)
            if song is None:
                msg(f'{id}: not found')
                continue
            print(f'{song} added {song.date}')
        return

    print(f'{len(catalog)} songs')

    if latest > 0:
        print(f'\nLatest {latest} songs:')
        for song in itertools.islice(reversed(catalog), latest):
            print(f'  {song.eid}  {song.date}  {song.group:5}  {song.artist}.{song.title}')

    if artists > 0:
        counter = Counter(song.artist for song in catalog)
        top = counter.most_common(artists)
        width = max(len(artist) for artist, count in top)
        print(f'\nTop {artists} artists:')
        for artist, count in counter.most_common(artists):
            print(f'  {artist.rjust(width)}  {"*" * count} ({count})')

#-----------------------------------------------------------------------------
# Command: ls-remote
#-----------------------------------------------------------------------------

@main.command(hidden=True)
@click.argument('remote')
@click.pass_obj
def ls_remote(context, remote):
    """List files on a remote."""
    backend = context.create_backend(remote)
    for path in backend.list():
        print(path)

#-----------------------------------------------------------------------------
# Command: dump
#-----------------------------------------------------------------------------

@main.command(hidden=True)
@click.pass_obj
def dump(context):
    """Dump the catalog to stdout.

    This is mainly for debugging the catalog parser and writer. The output
    should be identical to the input catalog file.
    """
    context.load_catalog().write(sys.stdout)

#-----------------------------------------------------------------------------
# Command: mhash
#-----------------------------------------------------------------------------

@main.command(hidden=True)
@click.argument('file')
@click.pass_obj
def mhash(context, file):
    """Calculate the mhash of an MP3 file."""
    with open(file, 'rb') as f:
        mhash = mp3_import(f, None, None)
    print(mhash)

#-----------------------------------------------------------------------------

if __name__ == '__main__':
    main(help_option_names=['-h', '--help'])

# vim:tw=78
