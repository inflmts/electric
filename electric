#!/usr/bin/env python3
##############################################################################
#
#         ,/
#       ,'/
#     ,' /___,  888888 88     888888  dP""b8 888888 88""Yb 88  dP""b8
#   .'__   ,'   88__   88     88__   dP   `"   88   88__dP 88 dP   `"
#      / ,'     88""   88  .o 88""   Yb        88   88"Yb  88 Yb
#     /,'       888888 88ood8 888888  YboodP   88   88  Yb 88  YboodP
#    /'
#
# ----------------------------------------------------------------------------
#                           Music Library Manager
# ----------------------------------------------------------------------------
#
#   Author: Daniel Li
#   Date: Sep 04 2024
#
#   Dependencies:
#     - python
#     - click
#     - adb (optional): for adb backend
#     - colorama (optional): for windows color support
#
##############################################################################

import click
from collections import defaultdict, namedtuple
import datetime
import hashlib
import operator
import os
import re
import shutil
import subprocess
import sys
import tempfile
import zlib

# output newline on all platforms
sys.stdout.reconfigure(newline='\n')

default_root = os.path.dirname(os.path.realpath(__file__))
mhash_len = 64
mabbrev_len = 12

# The list of valid groups.
GROUPS = ('core', 'extra')

##############################################################################
# Tag Overrides
##############################################################################

# The artist name and song title are automatically generated by converting
# their respective identifiers to uppercase and replacing dashes with spaces.
# For the majority of cases, this works fabulously. There are of course a few
# exceptions. For those, we override the automatically generated tag values
# here.

##############################################################################
# Utility Functions
##############################################################################

def err(message):
    sys.stderr.write(f'\033[1;31merror:\033[0m {message}\n')

def warn(message):
    sys.stderr.write(f'\033[1;33mwarning:\033[0m {message}\n')

def msg(message):
    sys.stderr.write(f'{message}\n')

def confirm(prompt, default=False):
    """Prompt the user for confirmation.

    If the response is empty (ie. the user simply pressed Enter),
    the specified default is returned if provided, otherwise False.
    If the response is 'Y' or 'y', returns True, otherwise returns False.
    """
    reply = input(prompt)
    return default if len(reply) == 0 else reply == 'y' or reply == 'Y'

def read_exact(f, size):
    buf = f.read(size)
    if len(buf) < size:
        raise EOFError('Unexpected end of file')
    return buf

def safe_rename(src, dest):
    # not actually safe
    if os.path.exists(dest):
        raise FileExistsError(dest)
    os.rename(src, dest)

##############################################################################
# Tags
##############################################################################

id3_header = b'ID3\x04\x00\x00\x00\x00\x01\x76'
mp3_bitrate_table = [None, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, None]
mp3_frequency_table = [44100, 48000, 32000, None]

def id3_encode_uint28(x):
    return bytes((x >> 21 & 0x7f, x >> 14 & 0x7f, x >> 7 & 0x7f, x & 0x7f))

def id3_encode_frame(id, content):
    return id + id3_encode_uint28(len(content)) + b'\x00\x00' + content

def id3_encode_text(id, content):
    return id3_encode_frame(id, b'\x03' + content.encode('utf-8') + b'\x00')

def id3_encode(tags):
    """Encode song tags as a 256-byte ID3v2.4.0 header."""
    data = (id3_header
        + id3_encode_text(b'TIT2', tags.title)
        + id3_encode_text(b'TPE1', tags.artist)
        + id3_encode_text(b'TALB', tags.album))
    if len(data) > 256:
        raise ValueError('ID3 tag exceeds 256 bytes')
    return data.ljust(256, b'\x00')

def id3_write(file, data):
    assert len(data) == 256
    with open(file, 'r+b') as f:
        if f.read(10) != id3_header:
            raise Exception('Invalid ID3 header')
        assert f.tell() == 10
        f.write(data[10:])

def id3_decode_int28(b):
    return (b[0] & 0x7f) << 21 | (b[1] & 0x7f) << 14 | (b[2] & 0x7f) << 7 | (b[3] & 0x7f)

def id3_skip(f):
    """Skip the ID3 header in a seekable readable stream."""
    header = read_exact(f, 10)
    if header[0:3] != b'ID3':
        raise Exception('id3: invalid magic')
    if header[5] != 0:
        raise Exception(f'id3: unrecognized flags ({header[5]:8b})')
    size = id3_decode_int28(header[6:10])
    f.seek(size, os.SEEK_CUR)

#def mp3_read_frame(f):
#    """Read an MP3 frame."""
#    header = f.read(4)
#    if not header:
#        return None
#    b0, b1, b2, b3 = header
#    if b0 != 0b11111111 or b1 & 0b11111110 != 0b11111010:
#        raise Exception('Unrecognized frame header')
#    bitrate = mp3_bitrate_table[b2 >> 4 & 0b1111]
#    if bitrate is None:
#        raise Exception('Invalid bitrate index')
#    freq = mp3_frequency_table[b2 >> 2 & 0b11]
#    if freq is None:
#        raise Exception('Invalid frequency index')
#    padding = b2 >> 1 & 0b1
#    if b2 & 0b1:
#        raise Exception('Private bit set')
#    if b3 & 0b11:
#        raise Exception('Emphasis bit set')
#    size = 144000 * bitrate // freq + padding
#    return header + read_exact(f, size - 4)

def mp3_normalize(inf, outf, tdata):
    """Replace the ID3 header and calculate the mhash."""
    id3_skip(inf)
    outf.write(tdata)
    sha256 = hashlib.sha256()
    buf = bytearray(8192)
    view = memoryview(buf)
    while size := inf.readinto1(buf):
        data = view[:size]
        sha256.update(data)
        outf.write(data)
    return sha256.hexdigest()

##############################################################################
# Songs
##############################################################################

SongTags = namedtuple('SongTags', ('title', 'artist', 'album'))

class Song:
    """
    Represents a song in the catalog.

    All attributes are readonly except for `mhash`. Note that changing `mhash`
    will cause the computed path to change as well.

    The `mhash` attribute may be None, which indicates that the song is not
    associated with a file. This can occur for a few reasons:

        - The song is currently being imported. It has been added to the
          catalog to obtain a song id, which is required to correctly tag the
          music file. For performance reasons, the mhash is calculated at the
          same time as the music file is being normalized.

        - The song has been dropped from the library but is still retained in
          the catalog for archival purposes.
    """

    def __init__(self, id, group, artist, title, date, mhash):
        self.id = id
        self.group = group
        self.artist = artist
        self.title = title
        self.date = date
        self.mhash = mhash
        self.tags = SongTags(
            title.upper().replace('-', ' '),
            artist.upper().replace('-', ' '),
            f'Electric {id:04}')
        self.tdata = id3_encode(self.tags)
        self.thash = '%08x' % (0xffffffff & zlib.crc32(self.tdata))

    def __str__(self):
        return f'E{self.id:04}[{self.group}.{self.artist}.{self.title}]'

    @property
    def mabbrev(self):
        if self.mhash is None:
            return None
        return self.mhash[:mabbrev_len]

    @property
    def basename(self):
        if self.mhash is None:
            return None
        return f'{self.artist}.{self.title}.{self.thash}{self.mabbrev}.mp3'

    @property
    def basepath(self):
        return os.path.join(self.group, self.basename)

    def write(self, f):
        id = self.id
        group = self.group
        artist = self.artist
        title = self.title
        date = self.date.strftime('%Y-%m-%d')
        mhash = self.mhash
        f.write(f'{id} {group} {artist} {title} {date} {mhash}\n')

##############################################################################
# Catalog
##############################################################################

class Catalog:
    def __init__(self):
        self._songs = {}
        self._lastid = 0

    def __iter__(self):
        return iter(self._songs.values())

    def __len__(self):
        return len(self._songs)

    @property
    def lastid(self):
        return self._lastid

    def add(self, id, group, artist, title, date, mhash):
        assert id > self._lastid
        song = Song(id, group, artist, title, date, mhash)
        self._songs[id] = song
        self._lastid = id
        return song

    def register(self, group, artist, title, mhash):
        date = datetime.date.today()
        return self.add(self._lastid + 1, group, artist, title, date, mhash)

    def replace(self, id, group, artist, title, date, mhash):
        if id not in self._songs:
            raise KeyError(id)
        song = Song(id, group, artist, title, date, mhash)
        self._songs[id] = song
        return song

    def get(self, id):
        return self._songs.get(id)

    def write(self, f):
        """Write the catalog to a file object."""
        for song in self:
            song.write(f)

class CatalogParseError(Exception):
    pass

def read_catalog(file):
    """Read the catalog from a file object."""

    id_regex = re.compile(r'[1-9][0-9]*')
    artist_regex = re.compile(r'[0-9a-z]+(?:-[0-9a-z]+)*')
    title_regex = artist_regex
    date_regex = re.compile(r'([0-9]{4})-([0-9]{2})-([0-9]{2})')
    mhash_regex = re.compile(r'[0-9a-f]{%d}' % mhash_len)

    catalog = Catalog()
    ln = 0

    def fail(message):
        raise CatalogParseError(f'line {ln}: {message}')

    for line in file:
        # increment line number before the loop to catch continue
        ln += 1
        # remove trailing newline
        line = line[:-1]

        fields = line.split(' ')
        if len(fields) != 6:
            fail(f'Expected 6 fields but {len(fields)} present')
        id, group, artist, title, date, mhash = fields

        if not id_regex.fullmatch(id):
            fail(f'Invalid id {id!r}')
        id = int(id)

        if group not in GROUPS:
            fail(f'Invalid group {group!r}')

        if not artist_regex.fullmatch(artist):
            fail(f'Invalid artist {artist!r}')

        if not title_regex.fullmatch(title):
            fail(f'Invalid title {title!r}')

        if not (match := date_regex.fullmatch(date)):
            fail(f'Invalid date {date!r}')
        y, m, d = match.groups()
        date = datetime.date(int(y), int(m), int(d))

        if not mhash_regex.fullmatch(mhash):
            fail(f'Invalid mhash {mhash!r}')

        catalog.add(id, group, artist, title, date, mhash)

    return catalog

##############################################################################
# Library Backends
##############################################################################

library_backends = {}

def library_backend(name):
    def decorator(cls):
        library_backends[name] = cls
        return cls
    return decorator

def create_backend(param):
    name = 'file'
    regex = re.compile('^[a-z]+:')
    match = regex.match(param)
    if match:
        name = param[:match.end() - 1]
        param = param[match.end():]
    if name not in remote_backends:
        err(f"unrecognized backend '{name}'")
        sys.exit(1)
    return remote_backends[name](param)

@library_backend('file')
class FileBackend:

    def __init__(self, param):
        self.root = param

    def pull(self, local_root, pull_files):
        for filepath in pull_files:
            msg(f"Copying {filepath}")
            src = os.path.join(self.root, filepath)
            dest = os.path.join(local_root, filepath)
            shutil.copyfile(src, dest)

    def push(self, local_root, push_files, prune_files):
        for filepath in push_files:
            msg(f"Copying {filepath}")
            src = os.path.join(local_root, filepath)
            dest = os.path.join(self.root, filepath)
            shutil.copyfile(src, dest)
        for filepath in prune_files:
            msg(f"Removing {filepath}")
            os.remove(os.path.join(self.root, filepath))

@library_backend('adb')
class AdbBackend:
    def __init__(self, param):
        self.root = param if len(param) else '/storage/emulated/0/Music'
        self._filelist = None

    def list(self):
        args = ['adb', 'shell', f"cd '{self.root}' && find {' '.join(GROUPIDS)} -mindepth 1 -maxdepth 1 -iname '*.mp3'"]
        output = subprocess.run(args, stdout=subprocess.PIPE, text=True, check=True).stdout
        return set(output.splitlines())

    def has(self, filepath):
        if self._filelist is None:
            self._filelist = self.list()
        return filepath in self._filelist

    def pull(self, pull_files):
        for filepath in pull_files:
            msg(f"Copying {filepath}")
            src = f'{self.root}/{filepath}'
            dest = os.path.join(local_root, filepath)
            subprocess.run(['adb', 'pull', src, dest], check=True)

    def push(self, local_root, push_files, prune_files):
        for filepath in push_files:
            msg(f"Copying {filepath}")
            src = os.path.join(local_root, filepath)
            dest = f'{self.root}/{filepath}'
            subprocess.run(['adb', 'push', src, dest], check=True)
        if len(prune_files) > 0:
            script = f"cd '{self.root}' && rm -f"
            for filepath in prune_files:
                script += f" '{filepath}'"
            subprocess.run(['adb', 'shell', script], check=True)

##############################################################################
# Command Line Parsing
##############################################################################

class Context:
    def __init__(self, root):
        self.root = root
        self.catalog_file = os.path.join(root, 'catalog.txt')
        self._catalog = None

    def catalog(self):
        if self._catalog is None:
            self.load_catalog()
        return self._catalog

    def load_catalog(self):
        with open(self.catalog_file) as f:
            self._catalog = read_catalog(f)
        return self._catalog

    def save_catalog(self):
        with open(self.catalog_file, 'w', newline='\n') as f:
            self._catalog.write(f)

@click.group()
@click.option('-r', '--root', metavar='DIR', default=default_root, show_default=True, help='root directory')
@click.pass_context
def main(ctx, root):
    ctx.obj = Context(root)

#-----------------------------------------------------------------------------
# Command: update
#-----------------------------------------------------------------------------

class LocalFile:
    def __init__(self, path, thash, mabbrev):
        self.path = path
        self.thash = thash
        self.mabbrev = mabbrev
        self.preserve = False

class PruneAction:
    def __init__(self, path):
        self.path = path

class ImportAction:
    def cleanup(self):
        os.remove(os.path.join(queue_dir, self.file + '~'))

# Replace is the only operation that will modify an existing song in the
# catalog. This is not something that I expect will occur often. The old
# file (if it exists) is not deleted and will show up as an orphan in the
# next invocation of update.

class ReplaceAction:
    def cleanup(self):
        os.remove(os.path.join(queue_dir, self.file))

def sync(self, catalog, library):
    pass

@main.command()
@click.option('-n', '--dry-run', is_flag=True, help='don\'t do anything, only show what would happen')
@click.option('--prune', is_flag=True, help='prune extraneous music files')
@click.option('--no-import', is_flag=True, help='do not check for music to import')
@click.pass_obj
def update(context, dry_run, prune, no_import):
    root = context.root
    queue_dir = os.path.join(root, 'queue')

    import_file_regex = re.compile(r'([a-z]+)\.([0-9a-z]+(?:-[0-9a-z]+)*)\.([0-9a-z]+(?:-[0-9a-z]+)*)\.mp3')
    replace_file_regex = re.compile(r'\+(\d+)\.mp3')
    basename_regex = re.compile(r'.*\.(?:([0-9a-f]{8})|x{8})([0-9a-f]{%d})\.mp3' % mabbrev_len)

    # Load catalog
    catalog = context.catalog()

    # Get a list of files
    local_files = {}
    for group in GROUPS:
        for name in os.listdir(os.path.join(root, group)):
            name = os.path.normcase(name)
            if not name.startswith('.') and (mat := basename_regex.fullmatch(name)):
                path = group + os.sep + name
                local_files[path] = LocalFile(path, mat[1], mat[2])

    # Find songs without a file
    missing = []
    for song in catalog:
        if song.mhash is None:
            continue
        file = local_files.get(song.basepath)
        if file is None:
            missing.append(song)
        else:
            file.preserve = True

    # Find files to rename/retag
    rename_actions = []
    for song in missing:
        for file in local_files.values():
            if file.mabbrev != song.mabbrev or file.preserve:
                continue
            file.preserve = True
            retag = song.thash != file.thash
            msg(f'\033[1;36m** {"retag" if retag else "rename"}:\033[0m {song}')
            rename_actions.append((song, file.path, retag))
            break
        else:
            warn(f'unable to find source for {song}')

    # Process queue directory for imports/replacements
    import_actions = []
    if not no_import:
        # Sort by modification time, oldest first
        entries = sorted(os.scandir(queue_dir),
                         key=lambda entry: entry.stat().st_mtime_ns)

        for entry in entries:
            name = entry.name
            if match := import_file_regex.fullmatch(name):
                group, artist, title = match.groups()
                if group not in GROUPS:
                    warn(f'{file}: invalid group {group!r}')
                    continue
                song = catalog.register(group, artist, title, None)
                msg(f'\033[1;32m>>import:\033[0m {song}')
                msg(f'    title: {song.tags.title}')
                msg(f'    artist: {song.tags.artist}')
                msg(f'    album: {song.tags.album}')
                import_actions.append((song, name))
                continue
            if match := replace_file_regex.fullmatch(name):
                id = int(match.group(1))
                song = catalog.get(id)
                if song is None:
                    warn(f'{file}: song E{id:04} doesn\'t exist')
                    continue
                msg(f'\033[1;32m** replace:\033[0m {song}')
                import_actions.append((song, name))
                continue

    # Find files to prune
    prune_actions = []
    for file in local_files.values():
        if not file.preserve:
            if prune:
                msg(f'\033[1;31prune:\033[0m {file.path}')
                prune_actions.append(file.path)
            else:
                warn(f'orphan: {file.path}')

    # Quit early if nothing to do
    if not (rename_actions or import_actions or prune_actions):
        return

    if dry_run or not confirm('Proceed [Y/n]? ', True):
        sys.exit(2)

    # Process rename/retag actions
    for song, srcpath, retag in rename_actions:
        msg(f'Renaming {srcpath} -> {song.basepath}')
        srcfile = os.path.join(root, srcpath)
        dstfile = os.path.join(root, song.basepath)
        if retag:
            tmpfile = os.path.join(root, song.group, f'{song.artist}.{song.title}.xxxxxxxx{song.mabbrev}.mp3')
            safe_rename(srcfile, tmpfile)
            id3_write(tmpfile, song.tdata)
            safe_rename(tmpfile, dstfile)
        else:
            safe_rename(srcfile, dstfile)

    # Process import/replace actions
    cleanup_files = []
    for song, name in import_actions:
        msg(f'Fixing {song}')
        srcfile = os.path.join(queue_dir, name)
        tmpfd, tmpfile = tempfile.mkstemp(prefix='import-', suffix='.mp3~', dir=queue_dir)
        with open(srcfile, 'rb') as srcf, open(tmpfd, 'wb') as tmpf:
            mhash = mp3_normalize(srcf, tmpf, song.tdata)
        song.mhash = mhash
        # The correct `dstpath` is only known after calculating the mhash
        dstfile = os.path.join(root, song.basepath)
        safe_rename(tmpfile, dstfile)
        cleanup_files.append(srcfile)

    # Save the catalog if necessary
    if import_actions:
        msg(f'Saving catalog...')
        context.save_catalog()

    # Process prune actions
    for path in prune_actions:
        msg(f'Removing {path}')
        os.remove(os.path.join(root, path))

    # Cleanup
    if cleanup_files:
        msg(f'Cleaning up...')
        for file in cleanup_files:
            pass #os.remove(file)

#-----------------------------------------------------------------------------
# Command: pull
#-----------------------------------------------------------------------------
# TODO: merge into update

#@main.command()
#@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
#@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
#@click.argument('remotes', nargs=-1, required=True)
#@click.pass_obj
#def pull(context, dry_run, yes, remotes):
#    """Get missing files from a remote.
#
#    If multiple remotes are specified, missing files will be searched in each
#    remote and the first remote that has the file will be used.
#    """
#    remotes = [(create_backend(remote), []) for remote in remotes]
#    catalog = context.catalog()
#    need_pull = False
#
#    for song in catalog.songs():
#        filepath = song.filepath()
#        if os.path.exists(os.path.join(context.root, filepath)):
#            continue
#        for backend, files in remotes:
#            if backend.has(filepath):
#                files.append(filepath)
#                need_pull = True
#                break
#        else:
#            warn(f"could not find source for {filepath}")
#
#    if not need_pull:
#        return # nothing to do
#    if dry_run:
#        return
#    if not (yes or confirm('Proceed [Y/n]? ', True)):
#        sys.exit(2)
#    for backend, files in remotes:
#        if len(files):
#            backend.pull(context.root, files)

#-----------------------------------------------------------------------------
# Command: push
#-----------------------------------------------------------------------------

@main.command()
@click.option('--prune', is_flag=True, help='prune extraneous files')
@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
@click.argument('remote')
@click.pass_obj
def push(context, prune, dry_run, yes, remote):
    """Send files to a remote."""
    backend = create_backend(remote)
    catalog = context.catalog()
    filelist = backend.list()
    push_files = []
    prune_files = []

    for song in catalog.songs():
        filepath = song.filepath()
        if filepath in filelist:
            if prune:
                filelist.remove(filepath)
            continue

        # check if local root has the file
        if os.path.exists(os.path.join(context.root, filepath)):
            msg(f"push {filepath}")
            push_files.append(filepath)
        else:
            warn(f"could not find source for {filepath}")

    if prune:
        for filepath in sorted(filelist):
            msg(f"prune {filepath}")
            prune_files.append(filepath)

    if len(push_files) == 0 and len(prune_files) == 0:
        return # nothing to do
    if dry_run:
        return
    if not (yes or confirm('Proceed [Y/n]? ', True)):
        sys.exit(2)
    backend.push(context.root, push_files, prune_files)

#-----------------------------------------------------------------------------
# Command: info
#-----------------------------------------------------------------------------

@main.command()
@click.pass_obj
def info(context):
    """Print statistics about the catalog."""
    catalog = context.catalog()
    msg(f'{len(catalog)} songs (last: E{catalog.lastid:04})')

#-----------------------------------------------------------------------------
# Command: dump
#-----------------------------------------------------------------------------

@main.command(hidden=True)
@click.pass_obj
def dump(context):
    context.catalog().write(sys.stdout)

#-----------------------------------------------------------------------------
# Command: mp3norm
#-----------------------------------------------------------------------------

@main.command(hidden=True)
@click.argument('title')
@click.argument('artist')
@click.argument('album')
@click.argument('src')
@click.argument('dest')
@click.pass_obj
def mp3norm(context, title, artist, album, src, dest):
    """Normalize an MP3 file."""
    tdata = id3_encode(SongTags(title, artist, album))
    with open(src, 'rb') as inf, open(dest, 'wb') as outf:
        mhash = mp3_normalize(inf, outf, tdata)
    print(f'mhash: {mhash}')

#-----------------------------------------------------------------------------

if __name__ == '__main__':
    main(help_option_names=['-h', '--help'])

# vim:tw=78
