#!/usr/bin/env python3
##############################################################################
#
#         ,/
#       ,'/
#     ,' /___,  888888 88     888888  dP""b8 888888 88""Yb 88  dP""b8
#   .'__   ,'   88__   88     88__   dP   `"   88   88__dP 88 dP   `"
#      / ,'     88""   88  .o 88""   Yb        88   88"Yb  88 Yb
#     /,'       888888 88ood8 888888  YboodP   88   88  Yb 88  YboodP
#    /'
#
# ----------------------------------------------------------------------------
#                           Music Library Manager
# ----------------------------------------------------------------------------
#
#   Author: Daniel Li
#   Date: Sep 04 2024
#
#   Dependencies:
#     - python
#     - adb (optional): for adb backend
#     - colorama (optional): for windows color support
#
##############################################################################

from collections import defaultdict, namedtuple
import datetime
import hashlib
import operator
import optparse
import os
import re
import shutil
import subprocess
import sys
import tempfile
import zlib

# output newline on all platforms
sys.stdout.reconfigure(newline='\n')

# fix colors on windows
if sys.platform == 'win32':
    try:
        import colorama
        colorama.just_fix_windows_console()
    except ImportError:
        pass

default_root = os.path.dirname(os.path.realpath(__file__))
mhash_len = 64
mhasha_len = 12

# The list of valid groups.
GROUPS = ('core', 'extra')

##############################################################################
# Tag Overrides
##############################################################################

# The artist name and song title are automatically generated by converting
# their respective identifiers to uppercase and replacing dashes with spaces.
# For the majority of cases, this works fabulously. There are of course a few
# exceptions. For those, we override the automatically generated tag values
# here.

ARTIST_NAME_OVERRIDES = {
    'a-39': 'A-39',
    'ex-lyd': 'EX-LYD',
    'tn-shi': 'TN-SHI'
}

SONG_TITLE_OVERRIDES = {
    ('au5', 'moonland-derpcat-remix'): 'MOONLAND (DERPCAT REMIX)',
    ('camellia', '1f1e33'): '#1F1E33'
}

##############################################################################
# Utility Functions
##############################################################################

def err(message):
    sys.stderr.write(f'\033[1;31merror:\033[0m {message}\n')

def warn(message):
    sys.stderr.write(f'\033[1;33mwarning:\033[0m {message}\n')

def msg(message):
    sys.stderr.write(f'{message}\n')

def confirm(prompt, default=False):
    """Prompt the user for confirmation.

    If the response is empty (ie. the user simply pressed Enter),
    the specified default is returned if provided, otherwise False.
    If the response is 'Y' or 'y', returns True, otherwise returns False.
    """
    reply = input(prompt)
    return default if len(reply) == 0 else reply == 'y' or reply == 'Y'

def read_exact(f, size):
    buf = f.read(size)
    if len(buf) < size:
        raise EOFError('Unexpected end of file')
    return buf

##############################################################################
# Tags
##############################################################################

id3_header = b'ID3\x04\x00\x00\x00\x00\x01\x76'
mp3_bitrate_table = [None, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, None]
mp3_frequency_table = [44100, 48000, 32000, None]

def id3_encode_uint28(x):
    return bytes((x >> 21 & 0x7f, x >> 14 & 0x7f, x >> 7 & 0x7f, x & 0x7f))

def id3_frame(id, content):
    return id + id3_encode_uint28(len(content)) + b'\x00\x00' + content

def id3_text(id, content):
    return id3_frame(id, b'\x03' + content.encode('utf-8') + b'\x00')

class Tags:
    def __init__(self, songid, artistid, titleid):
        self.title = titleid.upper().replace('-', ' ')
        self.artist = artistid.upper()
        self.album = f'Electric E{songid:04}'

        # encode the tag values as a fixed 256-byte ID3v2.4.0 tag
        data = (id3_header
            + id3_text(b'TIT2', self.title)
            + id3_text(b'TPE1', self.artist)
            + id3_text(b'TALB', self.album))
        if len(data) > 256:
            raise Exception('ID3 tag too long')
        data = data.rjust(256, b'\x00')
        assert len(data) == 256
        self.data = data
        self.hash = 0xffffffff & zlib.crc32(data)

    def write(self, file):
        """Write tags to the specified file in-place."""
        with open(file, 'r+b') as f:
            # make sure the header size is actually 256 bytes
            if f.read(10) != id3_header:
                raise Exception('File header does not match')
            assert f.tell() == 10
            f.write(self.data[10:256])

def id3_decode_int28(b):
    return (b[0] & 0x7f) << 21 | (b[1] & 0x7f) << 14 | (b[2] & 0x7f) << 7 | (b[3] & 0x7f)

def id3_skip(f):
    header = read_exact(f, 10)
    if header[0:3] != b'ID3':
        raise Exception('id3: invalid magic')
    if header[5] != 0:
        raise Exception(f'id3: unrecognized flags ({header[5]:8b})')
    size = id3_decode_int28(header[6:10])
    read_exact(f, size)

def mp3_read_frame(f):
    header = f.read(4)
    if not header:
        return None
    b0, b1, b2, b3 = header
    if b0 != 0b11111111 or b1 & 0b11111110 != 0b11111010:
        raise Exception('Unrecognized frame header')
    bitrate = mp3_bitrate_table[b2 >> 4 & 0b1111]
    if bitrate is None:
        raise Exception('Invalid bitrate index')
    freq = mp3_frequency_table[b2 >> 2 & 0b11]
    if freq is None:
        raise Exception('Invalid frequency index')
    padding = b2 >> 1 & 0b1
    if b2 & 0b1:
        raise Exception('Private bit set')
    if b3 & 0b11:
        raise Exception('Emphasis bit set')
    size = 144000 * bitrate // freq + padding
    data = read_exact(f, size - 4)
    return bitrate, freq, data

def mp3_normalize(input, output, tags):
    sha256 = hashlib.sha256()

    id3_skip(input)
    output.write(tags.data)

    # detect xing/info/lame frame
    frame = mp3_read_frame(input)
    if frame is None:
        raise Exception('No mp3 data')
    cbitrate, cfreq, data = frame
    if data[0x20:0x24] in (b'Xing', b'Info'):
        pass # skip
    else:
        sha256.update(data)
        output.write(data)

    while (frame := mp3_read_frame(input)) is not None:
        bitrate, freq, data = frame
        if bitrate != cbitrate or freq != cfreq:
            raise Exception('Non-constant bitrate and/or frequency')
        sha256.update(data)
        output.write(data)

    return sha256.hexdigest()

##############################################################################
# Songs
##############################################################################

SongTags = namedtuple('SongTags', ('title', 'artist', 'album'))

class Song:
    """
    Represents a song in the catalog.

    The `id` attribute is readonly. All other attributes except for `mhash`
    are also currently readonly, but this may change in the future. This is
    because the song tags would need to be recomputed if the artist or title
    ever did change.

    The `mhash` attribute may be None, which indicates that the song is not
    associated with a file. This can occur for a few reasons:

        - The song is currently being imported. It has been added to the
          catalog to obtain a song id, which is required to correctly tag the
          music file. For performance reasons, the mhash is calculated at the
          same time as the music file is being normalized.

        - The song has been dropped from the library but is still retained in
          the catalog for archival purposes.
    """

    def __init__(self, id, group, artist, title, date, mhash):
        self.id = id
        self.group = group
        self.artist = artist
        self.title = title
        self.date = date
        self.mhash = mhash
        self._tags = None

    def __str__(self):
        return f'E{self.id:04}[{self.group}.{self.artist}.{self.title}]'

    @property
    def mhasha(self):
        return self.mhash[:mhasha_len]

    @property
    def tags(self):
        if self._tags is None:
            self._tags = Tags(self.id, self.artist, self.title)
        return self._tags

    @property
    def thash(self):
        return self.tags.hash

    def write(self, f):
        id = self.id
        group = self.group
        artist = self.artist
        title = self.title
        date = self.date.strftime('%Y-%m-%d')
        mhash = self.mhash
        f.write(f'{id} {group} {artist} {title} {date} {mhash}\n')

    @property
    def basename(self):
        return f'{self.artist}.{self.title}.{self.thash}{self.mhasha}.mp3'

    @property
    def basepath(self):
        return os.path.join(self.group, self.basename)

##############################################################################
# Catalog
##############################################################################

class Catalog:
    def __init__(self):
        self._songs = {}
        self._lastid = 0

    def __iter__(self):
        return iter(self._songs.values())

    def __len__(self):
        return len(self._songs)

    @property
    def lastid(self):
        return self._lastid

    def add(self, id, group, artist, title, date, mhash):
        assert id > self._lastid
        song = Song(id, group, artist, title, date, mhash)
        self._songs[id] = song
        self._lastid = id
        return song

    def register(self, group, artist, title, mhash):
        date = datetime.date.today()
        return self.add(self._lastid + 1, group, artist, title, date, mhash)

    def get(self, id):
        return self._songs.get(id)

    def write(self, f):
        """Write the catalog to a file object."""
        for song in self:
            song.write(f)

class CatalogParseError(Exception):
    pass

class CatalogParseState:
    def __init__(self):
        self.line = 0

    def inc(self):
        self.line += 1

    def fail(self, message):
        raise CatalogParseError(f'line {self.line}: {message}')

def read_catalog(file):
    """Read the catalog from a file object."""

    id_regex = re.compile(r'[1-9][0-9]*')
    artist_regex = re.compile(r'[0-9a-z]+(?:-[0-9a-z]+)*')
    title_regex = artist_regex
    date_regex = re.compile(r'([0-9]{4})-([0-9]{2})-([0-9]{2})')
    mhash_regex = re.compile(r'[0-9a-f]{%d}' % mhash_len)

    catalog = Catalog()
    state = CatalogParseState()

    for line in file:
        # increment line number before the loop to catch continue
        state.inc()
        # remove trailing newline
        line = line[:-1]

        fields = line.split(' ')
        if len(fields) != 6:
            state.fail(f'Expected 6 fields but {len(fields)} present')
        id, group, artist, title, date, mhash = fields

        if not id_regex.fullmatch(id):
            state.fail(f'Invalid id {id!r}')
        id = int(id)

        if group not in GROUPS:
            state.fail(f'Invalid group {group!r}')

        if not artist_regex.fullmatch(artist):
            state.fail(f'Invalid artist {artist!r}')

        if not title_regex.fullmatch(title):
            state.fail(f'Invalid title {title!r}')

        if not (match := date_regex.fullmatch(date)):
            state.fail(f'Invalid date {date!r}')
        y, m, d = match.groups()
        date = datetime.date(int(y), int(m), int(d))

        if not mhash_regex.fullmatch(mhash):
            state.fail(f'Invalid mhash {mhash!r}')

        catalog.add(id, group, artist, title, date, mhash)

    return catalog

##############################################################################
# Remote Backends
##############################################################################

remote_backends = {}

def remote_backend(name):
    def decorator(cls):
        remote_backends[name] = cls
        return cls
    return decorator

def create_backend(param):
    name = 'file'
    regex = re.compile('^[a-z]+:')
    match = regex.match(param)
    if match:
        name = param[:match.end() - 1]
        param = param[match.end():]
    if name not in remote_backends:
        err(f"unrecognized backend '{name}'")
        sys.exit(1)
    return remote_backends[name](param)

@remote_backend('file')
class FileBackend:
    def __init__(self, param):
        self.root = param

    def list(self):
        return {f'{groupid}/{file}'
                for groupid in GROUPIDS
                for file in os.listdir(os.path.join(self.root, groupid))
                if not file.startswith('.') and file.endswith('.mp3')}

    def has(self, filepath):
        return os.path.exists(os.path.join(self.root, filepath))

    def pull(self, local_root, pull_files):
        for filepath in pull_files:
            msg(f"Copying {filepath}")
            src = os.path.join(self.root, filepath)
            dest = os.path.join(local_root, filepath)
            shutil.copyfile(src, dest)

    def push(self, local_root, push_files, prune_files):
        for filepath in push_files:
            msg(f"Copying {filepath}")
            src = os.path.join(local_root, filepath)
            dest = os.path.join(self.root, filepath)
            shutil.copyfile(src, dest)
        for filepath in prune_files:
            msg(f"Removing {filepath}")
            os.remove(os.path.join(self.root, filepath))

@remote_backend('adb')
class AdbBackend:
    def __init__(self, param):
        self.root = param if len(param) else '/storage/emulated/0/Music'
        self._filelist = None

    def list(self):
        args = ['adb', 'shell', f"cd '{self.root}' && find {' '.join(GROUPIDS)} -mindepth 1 -maxdepth 1 -iname '*.mp3'"]
        output = subprocess.run(args, stdout=subprocess.PIPE, text=True, check=True).stdout
        return set(output.splitlines())

    def has(self, filepath):
        if self._filelist is None:
            self._filelist = self.list()
        return filepath in self._filelist

    def pull(self, pull_files):
        for filepath in pull_files:
            msg(f"Copying {filepath}")
            src = f'{self.root}/{filepath}'
            dest = os.path.join(local_root, filepath)
            subprocess.run(['adb', 'pull', src, dest], check=True)

    def push(self, local_root, push_files, prune_files):
        for filepath in push_files:
            msg(f"Copying {filepath}")
            src = os.path.join(local_root, filepath)
            dest = f'{self.root}/{filepath}'
            subprocess.run(['adb', 'push', src, dest], check=True)
        if len(prune_files) > 0:
            script = f"cd '{self.root}' && rm -f"
            for filepath in prune_files:
                script += f" '{filepath}'"
            subprocess.run(['adb', 'shell', script], check=True)

##############################################################################
# Command Line Parsing
##############################################################################

commands = {}

def command():
    def decorator(fn):
        commands[fn.__name__] = fn
        return fn
    return decorator

class OptionParser(optparse.OptionParser):
    def error(self, message):
        err(message)
        sys.exit(2)

class Context:
    def __init__(self):
        self._catalog = None

    def load_catalog(self):
        if self._catalog is None:
            with open(self.catalog_file) as f:
                self._catalog = read_catalog(f)
        return self._catalog

    def save_catalog(self):
        with open(self.catalog_file, 'w', newline='\n') as f:
            self._catalog.write(f)

def main():
    parser = OptionParser()
    parser.disable_interspersed_args()
    parser.add_option('-r', '--root', metavar='DIR', default=default_root, help='root directory [default: %default]')
    opts, args = parser.parse_args()

    context = Context()
    context.root = opts.root
    context.catalog_file = os.path.join(opts.root, 'catalog.txt')

    if args:
        func = commands.get(args[0])
        if func is None:
            parser.error(f'invalid command {args[0]!r}')
        args[0] = f'{sys.argv[0]} {args[0]}'
        sys.argv = args
        func(context)
    else:
        parser.print_help()
        sys.exit(2)

#-----------------------------------------------------------------------------
# Command: update
#-----------------------------------------------------------------------------

@command()
def update(context):
    parser = OptionParser(usage='%prog [options]')
    parser.add_option('-n', '--dry-run', action='store_true', help='don\'t do anything, only show what would happen')
    parser.add_option('--prune', action='store_true', help='prune extraneous music files')
    parser.add_option('--no-import', action='store_true', help='do not check for music to import')
    opts, args = parser.parse_args()

    root = context.root
    dry_run = opts.dry_run
    prune = opts.prune
    no_import = opts.no_import
    queue_dir = os.path.join(root, 'queue')

    import_file_regex = re.compile(r'([a-z]+)\.([0-9a-z]+(?:-[0-9a-z]+)*)\.([0-9a-z]+(?:-[0-9a-z]+)*)\.mp3')
    replace_file_regex = re.compile(r'\+E(\d{4})\.mp3')
    basename_regex = re.compile(r'.*\.(?:([0-9a-f]{8})|x{8})([0-9a-f]{%d})\.mp3$' % mhasha_len)

    class Source:
        def __init__(self, path, thash, mhasha):
            self.path = path
            self.thash = thash
            self.mhasha = mhasha
            self.used = False

    class RenameAction:
        def __init__(self, song, source):
            self.song = song
            self.source = source

        def exec(self):
            os.rename(os.path.join(root, song.basepath),
                      os.path.join(root, source.path))

    class RetagAction:
        def __init__(self, song, source):
            self.song = song
            self.source = source

        def exec(self):
            song = self.song
            source = self.source
            tmpfile = os.path.join(root, song.group, f'{song.artist}.{song.title}.xxxxxxxx{song.mhasha}.mp3')
            os.rename(os.path.join(root, source.path), tmpfile)
            song.tags.write(tmpfile)
            os.rename(tmpfile, os.path.join(root, song.basepath))

    class PruneAction:
        def __init__(self, path):
            self.path = path

    class ImportAction:
        def __init__(self, group, artist, title, tags, date, file):
            self.group = group
            self.artist = artist
            self.title = title
            self.tags = tags
            self.date = date
            self.file = file

        def exec(self):
            infile = os.path.join(queue_dir, self.file)
            outfd, outfile = tempfile.mkstemp(prefix='import-', suffix='.mp3~', dir=queue_dir)
            with open(infile, 'rb') as input, open(outfd, 'wb') as output:
                mhash = mp3_normalize(input, output, tags)
            song = catalog.register(group, artist, title, mhash)
            os.rename(outfile, os.path.join(root, song.basepath))
            os.rename(infile, infile + '~')

        def cleanup(self):
            os.remove(os.path.join(queue_dir, self.file + '~'))

    # Replace is the only operation that will modify an existing song in the
    # catalog. This is not something that I expect will occur often. The old
    # file (if it exists) is not deleted and will show up as an orphan in the
    # next invocation of update.

    class ReplaceAction:
        def __init__(self, song, file):
            self.song = song
            self.file = file

        def exec(self):
            infile = os.path.join(queue_dir, self.file)
            outfd, outfile = tempfile.mkstemp(prefix='replace-', suffix='.mp3~', dir=queue_dir)
            with open(infile, 'rb') as input, open(outfd, 'wb') as output:
                mhash = mp3_normalize(input, output, self.song.tags)
            song.mhash = mhash
            os.rename(outfile, os.path.join(root, song.basepath))

        def cleanup(self):
            os.remove(os.path.join(queue_dir, self.file))

    # load catalog
    catalog = context.load_catalog()
    actions = []

    # get a list of potential file sources
    local_sources_by_path = {}
    local_sources_by_mhasha = {}
    for group in GROUPS:
        for name in os.listdir(os.path.join(context.root, group)):
            if name.startswith('.') or not name.endswith('.mp3'):
                continue
            match = basename_regex.match(name)
            if not match:
                warn(f'ignoring file: {group}/{name}')
                continue
            path = os.path.join(group, name)
            thash, mhasha = match.groups()
            source = LocalUpdateSource(path, thash, mhasha)
            local_sources_by_path[path] = source
            local_sources_by_mhasha.setdefault(mhasha, source)

    # process queue directory for imports & replacements
    if not no_import:
        for entry in sorted(os.scandir(queue_dir), key=lambda entry: entry.stat().st_mtime_ns):
            file = entry.name
            match = import_file_regex.fullmatch(file)
            if match:
                group, artist, title = match.groups()
                if group not in GROUPS:
                    warn(f'{file}: invalid group {group!r}')
                    continue
                tags = Tags(None, artist, title)
                date = datetime.date.today()

                msg(f'\033[1;32mimport:\033[0m {song}')
                msg(f'  title: {tags.title}')
                msg(f'  artist: {tags.artist}')
                msg(f'  album: {tags.album}')
                actions.append(ImportAction(group, artist, title, tags, date, file))
                continue

            match = replace_file_regex.fullmatch(file)
            if match:
                id = int(match.group(1))
                song = catalog.get(id)
                if song is None:
                    warn(f'{file}: song E{id:04} doesn\'t exist')
                    continue

                msg(f'\033[1;31mreplace:\033[0m {song}')
                song.mtime = None
                actions.append(ReplaceAction(song, file))
                continue

    missing = []
    for song in catalog:
        if song.mtime is None:
            # song is being replaced
            continue
        source = local_sources_by_path.get(song.basepath)
        if source is None:
            missing.append(song)
        else:
            source.used = True

    # update actions
    #
    #   - If the source is local and unused:
    #       - If the tag hash matches:
    #           - Rename into place.
    #       - If the tag hash does not match:
    #           - Rename into untagged space.
    #           - Retag.
    #           - Rename into place.
    #   - Otherwise:
    #       - Copy and retag into temporary location.
    #       - Rename into place.
    #
    for song in missing:
        source = local_sources_by_mhasha.get(song.mhasha)
        if source is not None and not source.used:
            source.used = True
            if song.thash == source.thash:
                msg(f'\033[1;36mrename:\033[0m {song}')
                actions.append(RenameAction(context, song, source.path))
            else:
                msg(f'\033[1;36mretag:\033[0m {song}')
                actions.append(RetagAction(context, song, source.path))
        else:
            warn(f'unable to find source for {song}')

    # prune actions
    for source in local_sources_by_path.values():
        if not source.used:
            if prune:
                msg(f'\033[1;31prune:\033[0m {source.path}')
                actions.append(PruneAction(context, source.path))
            else:
                warn(f'orphan: {source.path}')

    # quit early if nothing to do
    if not actions:
        return

    if dry_run or not confirm('Proceed [Y/n]? ', True):
        sys.exit(2)

    # process actions
    for action in actions:
        action.exec()

    # save the catalog
    context.save_catalog()

    # now it should be safe to cleanup
    for action in actions:
        action.cleanup()

#-----------------------------------------------------------------------------
# Command: pull
#-----------------------------------------------------------------------------
# TODO: merge into update

#@main.command()
#@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
#@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
#@click.argument('remotes', nargs=-1, required=True)
#@click.pass_obj
#def pull(context, dry_run, yes, remotes):
#    """Get missing files from a remote.
#
#    If multiple remotes are specified, missing files will be searched in each
#    remote and the first remote that has the file will be used.
#    """
#    remotes = [(create_backend(remote), []) for remote in remotes]
#    catalog = context.load_catalog()
#    need_pull = False
#
#    for song in catalog.songs():
#        filepath = song.filepath()
#        if os.path.exists(os.path.join(context.root, filepath)):
#            continue
#        for backend, files in remotes:
#            if backend.has(filepath):
#                files.append(filepath)
#                need_pull = True
#                break
#        else:
#            warn(f"could not find source for {filepath}")
#
#    if not need_pull:
#        return # nothing to do
#    if dry_run:
#        return
#    if not (yes or confirm('Proceed [Y/n]? ', True)):
#        sys.exit(2)
#    for backend, files in remotes:
#        if len(files):
#            backend.pull(context.root, files)

#-----------------------------------------------------------------------------
# Command: push
#-----------------------------------------------------------------------------

#@main.command()
#@click.option('--prune', is_flag=True, help='prune extraneous files')
#@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
#@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
#@click.argument('remote')
#@click.pass_obj
def push(context, prune, dry_run, yes, remote):
    """Send files to a remote."""
    backend = create_backend(remote)
    catalog = context.load_catalog()
    filelist = backend.list()
    push_files = []
    prune_files = []

    for song in catalog.songs():
        filepath = song.filepath()
        if filepath in filelist:
            if prune:
                filelist.remove(filepath)
            continue

        # check if local root has the file
        if os.path.exists(os.path.join(context.root, filepath)):
            msg(f"push {filepath}")
            push_files.append(filepath)
        else:
            warn(f"could not find source for {filepath}")

    if prune:
        for filepath in sorted(filelist):
            msg(f"prune {filepath}")
            prune_files.append(filepath)

    if len(push_files) == 0 and len(prune_files) == 0:
        return # nothing to do
    if dry_run:
        return
    if not (yes or confirm('Proceed [Y/n]? ', True)):
        sys.exit(2)
    backend.push(context.root, push_files, prune_files)

#-----------------------------------------------------------------------------
# Command: info
#-----------------------------------------------------------------------------

@command()
def info(context):
    parser = OptionParser()
    parser.add_option('--dump', action='store_true', help='dump catalog to stdout')
    opts, args = parser.parse_args()

    catalog = context.load_catalog()

    if opts.dump:
        catalog.write(sys.stdout)
        return

    msg(f'{len(catalog)} songs (last: E{catalog.lastid:04})')

#-----------------------------------------------------------------------------

if __name__ == '__main__':
    main()

# vim:tw=78
