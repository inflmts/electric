#!/usr/bin/env python3
##############################################################################
#
#         ,/
#       ,'/
#     ,' /___,  888888 88     888888  dP""b8 888888 88""Yb 88  dP""b8
#   .'__   ,'   88__   88     88__   dP   `"   88   88__dP 88 dP   `"
#      / ,'     88""   88  .o 88""   Yb        88   88"Yb  88 Yb
#     /,'       888888 88ood8 888888  YboodP   88   88  Yb 88  YboodP
#    /'
#
# ----------------------------------------------------------------------------
#                           Music Library Manager
# ----------------------------------------------------------------------------
#
#   Copyright (c) 2024-2025 Daniel Li
#
#   This software is licensed under the GNU GPLv3 or later version.
#
#   Dependencies:
#     - python 3.8
#     - ffmpeg (optional): import normalization
#     - adb (optional): adb backend
#
##############################################################################

import datetime
import os
import re
import sys
import zlib

# output newline on all platforms
sys.stdout.reconfigure(newline='\n')
sys.stderr.reconfigure(newline='\n')

default_root = os.path.dirname(os.path.realpath(__file__))

id_regex = re.compile(r'[1-9][0-9]*')
date_regex = re.compile(r'([0-9]{4})-([0-9]{2})-([0-9]{2})')
artist_regex = re.compile(r'[0-9a-z]+(?:-[0-9a-z]+)*')
title_regex = artist_regex
mhash_regex = re.compile(r'[0-9a-f]{64}')
file_regex = re.compile(r'.*[/\.]([0-9a-f]{12})([0-9a-f]{4})?\.mp3')

##############################################################################
# Utility Functions
##############################################################################

def err(message):
    sys.stderr.write(f'\033[1;31merror:\033[0m {message}\n')

def warn(message):
    sys.stderr.write(f'\033[1;33mwarning:\033[0m {message}\n')

def msg(message):
    sys.stderr.write(f'{message}\n')

def confirm(prompt, default=False):
    """
    Prompt the user for confirmation.

    If the response is empty (ie. the user simply pressed Enter),
    the specified default is returned if provided, otherwise False.
    If the response is 'Y' or 'y', returns True, otherwise returns False.
    """
    options = '[Y/n]' if default else '[y/N]'
    sys.stderr.write(f'{prompt} {options} ')
    reply = input()
    return default if len(reply) == 0 else reply == 'y' or reply == 'Y'

def copy_file(src, dest):
    # Similar to copyfileobj() from the standard library
    # https://github.com/python/cpython/blob/main/Lib/shutil.py
    buf = bytearray(65536)
    view = memoryview(buf)
    while size := src.readinto(buf):
        dest.write(view[:size])

def hash_file(f):
    # Based on file_digest() from the standard library
    # https://github.com/python/cpython/blob/main/Lib/hashlib.py
    import hashlib
    buf = bytearray(65536)
    view = memoryview(buf)
    digest = hashlib.sha256()
    while size := f.readinto(buf):
        digest.update(view[:size])
    return digest.hexdigest()

##############################################################################
# ID3
##############################################################################

# Resources:
#   - https://mutagen-specs.readthedocs.io/en/latest/id3/id3v2.4.0-structure.html
#   - https://mutagen-specs.readthedocs.io/en/latest/id3/id3v2.4.0-frames.html
#   - https://en.wikipedia.org/wiki/MP3#File_structure
#   - http://mpgedit.org/mpgedit/mpeg_format/mpeghdr.htm
#   - https://www.datavoyage.com/mpgscript/mpeghdr.htm (same)
#   - http://gabriel.mp3-tech.org/mp3infotag.html
#   - https://forum.powerbasic.com/forum/user-to-user-discussions/programming/54515-lame-header-frame

id3_header = b'ID3\x04\x00\x00\x00\x00\x01\x76'

def id3_encode_uint28(x):
    return bytes((x >> 21 & 0x7f, x >> 14 & 0x7f, x >> 7 & 0x7f, x & 0x7f))

def id3_encode_frame(id, content):
    return id + id3_encode_uint28(len(content)) + b'\x00\x00' + content

def id3_encode_text(id, content):
    return id3_encode_frame(id, b'\x03' + content.encode('utf-8') + b'\x00')

def id3_encode(title, artist, album):
    """Encode song tags as a 256-byte ID3v2.4.0 header."""
    data = (id3_header
        + id3_encode_text(b'TIT2', title)
        + id3_encode_text(b'TPE1', artist)
        + id3_encode_text(b'TALB', album))
    if len(data) > 256:
        raise ValueError('ID3 tag exceeds 256 bytes')
    data = data.ljust(256, b'\x00')
    assert len(data) == 256
    return data

def id3_write(file, data):
    assert len(data) == 256
    with open(file, 'r+b') as f:
        if f.read(10) != id3_header:
            raise RuntimeError('Invalid ID3 header')
        assert f.tell() == 10
        f.write(data[10:])

##############################################################################
# Songs
##############################################################################

class Song:
    """
    Represents a song in the catalog.

    All attributes are readonly.

    `mhash` may be None, which indicates that the song does not have an
    associated file. In this case, `file` will also be None.
    """

    def __init__(self, id, date, artists, title, mhash):
        self.id = id
        self.date = date
        self.artists = artists
        self.title = title
        self.mhash = mhash

        # The artist name and song title are generated by converting their
        # respective identifiers to uppercase and replacing dashes with spaces.
        # This simple scheme works well and looks nice in music players.

        self.title_tag = title.upper().replace('-', ' ')
        self.artist_tag = ', '.join(artists).upper().replace('-', ' ')
        self.album_tag = 'Electric'
        self.tdata = tdata = id3_encode(self.title_tag, self.artist_tag, self.album_tag)
        self.thash = thash = f'{zlib.crc32(tdata) >> 16:04x}'

        if mhash is not None:
            self.mabbrev = mabbrev = mhash[:12]
            self.file = f'core/{id:04}.{",".join(artists)}.{title}.{mabbrev}{thash}.mp3'
        else:
            self.mabbrev = None
            self.file = None

    def __str__(self):
        return self.file

    def write(self, f):
        id = self.id
        date = self.date.strftime('%Y-%m-%d')
        artists = ','.join(self.artists)
        title = self.title
        mhash = '-' if self.mhash is None else self.mhash
        f.write(f'{id} {date} {artists} {title} {mhash}\n')

##############################################################################
# Catalog
##############################################################################

class CatalogError(Exception):
    pass

class Catalog:
    def __init__(self, file=None):
        self.file = file
        self._songs = []
        self._songs_by_mabbrev = {}

    def __len__(self):
        return len(self._songs)

    def __getitem__(self, id):
        return self._songs[id - 1]

    def __iter__(self):
        return iter(self._songs)

    def __reversed__(self):
        return reversed(self._songs)

    def __contains__(self, id):
        return id >= 1 and id <= len(self._songs)

    def get_mabbrev(self, mabbrev):
        return self._songs_by_mabbrev.get(mabbrev)

    def add(self, id, date, artists, title, mhash):
        lastid = len(self._songs)
        if id > 9999:
            raise CatalogError(f'ID too large: {id}')
        if id != lastid + 1:
            raise CatalogError(f'Attempted to add non-consecutive {id} after {lastid}')
        song = Song(id, date, artists, title, mhash)
        conflict = self.get_mabbrev(song.mabbrev)
        if conflict:
            raise CatalogError(f'{song} and {conflict} have the same mabbrev')
        self._songs.append(song)
        self._songs_by_mabbrev[song.mabbrev] = song
        return song

    def register(self, artists, title, mhash):
        id = len(self._songs) + 1
        date = datetime.date.today()
        return self.add(id, date, artists, title, mhash)

    def replace(self, id, date, artists, title, mhash):
        raise NotImplementedError()
        assert id in self
        del self._songs_by_mabbrev[self._songs[id].mabbrev]
        song = Song(id, date, artists, title, mhash)
        self._songs[id] = song
        self._songs_by_mabbrev[song.mabbrev] = song

    def classify_files(self, files):
        live = {}
        dead = {}
        duplicates = []

        for file in files:
            match = file_regex.fullmatch(file)
            if match is None:
                continue
            mabbrev, thash = match.groups()
            song = self.get_mabbrev(mabbrev)
            if song is not None:
                if file == song.file:
                    if song in live:
                        conflict_file, conflict_thash = live[song]
                        duplicates.append(conflict_file)
                    live[song] = file, thash
                elif song in live:
                    duplicates.append(file)
                else:
                    live[song] = file, thash
            else:
                dead_file = f'old/{mabbrev}.mp3'
                if file == dead_file:
                    if mabbrev in dead:
                        conflict_file = dead[mabbrev]
                        duplicates.append(conflict_file)
                elif mabbrev in dead:
                    duplicates.append(file)
                else:
                    dead[mabbrev] = file

        return live, dead, duplicates

    def parse_line(self, line):
        fields = line.split(' ')
        if len(fields) != 5:
            raise CatalogError(f'Expected 5 fields but {len(fields)} present')
        id, date, artist, title, mhash = fields

        if not id_regex.fullmatch(id):
            raise CatalogError(f'Invalid id {id!r}')
        id = int(id)

        if date == '-':
            date = datetime.date.today()
        else:
            if not (match := date_regex.fullmatch(date)):
                raise CatalogError(f'Invalid date {date!r}')
            y, m, d = match.groups()
            date = datetime.date(int(y), int(m), int(d))

        artists = artist.split(',')
        for artist in artists:
            if not artist_regex.fullmatch(artist):
                raise CatalogError(f'Invalid artist {artist!r}')

        if not title_regex.fullmatch(title):
            raise CatalogError(f'Invalid title {title!r}')

        if mhash == '-':
            mhash = None
        elif not mhash_regex.fullmatch(mhash):
            raise CatalogError(f'Invalid mhash {mhash!r}')

        self.add(id, date, artists, title, mhash)

    def read(self, f):
        """
        Read the catalog from a file object.

        Raises CatalogError if a parsing error occurs.
        """

        lineno = 0
        for line in f:
            # increment line number before the loop to catch continue
            lineno += 1
            # remove trailing newline
            line = line[:-1]
            try:
                self.parse_line(line)
            except CatalogError as e:
                raise CatalogError(f'Line {lineno}: {e}')

    def load(self):
        with open(self.file) as f:
            self.read(f)

    def write(self, f):
        """Write the catalog to a file object."""
        for song in self:
            song.write(f)

    def save(self):
        tmpfile = self.file + '.lock'
        tmpf = open(tmpfile, 'x', newline='\n')
        try:
            with tmpf:
                self.write(tmpf)
        except:
            os.remove(tmpfile)
            raise
        os.replace(tmpfile, self.file)

##############################################################################
# Backends
##############################################################################

backends = {}

class BackendError(Exception):
    pass

class Backend:
    def __init_subclass__(cls, name, **kwargs):
        backends[name] = cls

    def connect(self):
        pass

    def disconnect(self):
        pass

# Backends must implement these methods:
#
#   __init__(context, param)
#       Creates the backend from the user-supplied parameter.
#       The constructor should raise BackendError if the format of the
#       parameter is invalid.
#
#   list()
#       Returns a list of files in the backend.
#
#   fetch(files)
#       Retrieve the specified files from the remote.
#
#   send(files, renames, prunes)
#       Executes the specified updates on the remote.
#
#       files is a list of files to push.
#
#       renames is a list of (src, dest, data) of files to rename.
#       data is the tags to apply if needed, otherwise None.
#       If the backend does not support renames or in-place retags, it may
#       push the dest file instead. In this case, src is ignored.
#
#       prunes is a list of files to remove.
#
# These methods are optional:
#
#   connect()
#       Create a persistent connection to the backend and/or perform other
#       required setup. This will be called once on initialization.
#
#   disconnect()
#       Terminate a persistent connection to the backend and/or perform other
#       cleanup actions. This will always be the last method called.
#

class FileBackend(Backend, name='file'):
    def __init__(self, context, param):
        self.context = context
        self.root = param

    def list(self):
        return [
            f'core/{file}'
            for file in os.listdir(os.path.join(self.root, 'core'))
            if file.endswith('.mp3')]

    def fetch(self, files):
        import shutil

        for file in files:
            msg(f'Pulling {file}')
            srcfile = os.path.join(self.root, file)
            destfile = os.path.join(self.context.root, file)
            shutil.copyfile(srcfile, destfile)

    def send(self, files, renames, prunes):
        import shutil

        for file in files:
            msg(f'Pushing {file}')
            srcfile = os.path.join(self.context.root, file)
            destfile = os.path.join(self.root, file)
            shutil.copyfile(srcfile, destfile)

        for src, dest, data in renames:
            msg(f'Renaming {src} -> {dest}')
            srcfile = os.path.join(self.root, src)
            destfile = os.path.join(self.root, dest)
            if data is not None:
                id3_write(srcfile, data)
            os.rename(srcfile, destfile)

        for file in prunes:
            msg(f'Removing {file}')
            os.remove(os.path.join(self.root, file))

class AdbBackend(Backend, name='adb'):
    def __init__(self, context, param):
        self.context = context
        self.root = param or '/storage/emulated/0/Music'

    def list(self):
        import subprocess

        command = f'cd \'{self.root}\' && find core old -mindepth 1 -maxdepth 1 -name "*.mp3"'
        result = subprocess.run(
            ['adb', 'shell', command],
            stdout=subprocess.PIPE,
            text=True)
        if result.returncode:
            raise BackendError(f'adb shell exited {result.returncode}: {command}')
        return result.stdout.splitlines()

    def fetch(self, files):
        import subprocess

        for file in files:
            msg(f'Pulling {file}')
            srcfile = f'{self.root}/{file}'
            destfile = os.path.join(self.context.root, file)
            result = subprocess.run(['adb', 'pull', srcfile, destfile])
            if result.returncode:
                raise BackendError(f'adb pull exited {result.returncode}')

    def send(self, files, renames, prunes):
        import subprocess

        for file in files:
            msg(f'Pushing {file}')
            srcfile = os.path.join(self.context.root, file)
            destfile = f'{self.root}/{file}'
            result = subprocess.run(['adb', 'push', srcfile, destfile])
            if result.returncode:
                raise BackendError(f'adb push exited {result.returncode}')

        if renames or prunes:
            commands = [f'set -e\ncd \'{self.root}\'\n']
            for src, dest, tdata in renames:
                commands.append(f'echo \'Renaming {src} -> {dest}\'\n')
                if tdata is not None:
                    tdata_escaped = ''.join(f'\\x{byte:02x}' for byte in tdata)
                    assert len(tdata_escaped) == 1024
                    commands.append(f'echo -ne \'{tdata_escaped}\' 1<> \'{src}\'\n')
                commands.append(f'mv \'{src}\' \'{dest}\'\n')
            for file in prunes:
                commands.append(f'echo \'Removing {file}\'\n')
                commands.append(f'rm \'{file}\'\n')
            result = subprocess.run(
                ['adb', 'shell'],
                input=''.join(commands),
                text=True)
            if result.returncode:
                raise BackendError(f'adb shell exited {result.returncode}')

##############################################################################
# Import
##############################################################################

def import_song(context, artists, title, file):
    import shutil
    import subprocess

    tmpfile = os.path.join(context.root, 'core', '.import~.mp3')
    tmpdestfile = os.path.join(context.root, 'core', '.import~2.mp3')

    # Normalize using ffmpeg. This does a few things:
    #
    #   - makes sure it's actually a MP3
    #   - removes the cover art
    #   - removes the ID3 tag, we handle that ourselves
    #   - gets a Xing/LAME header so ffprobe doesn't complain
    #
    # The file is not recoded, so it should be safe to repeatedly import a
    # file without loss of quality, although there's currently no known use
    # for this feature. It may or may not produce the same mhash.

    subprocess.run([
        'ffmpeg', '-y',
        '-hide_banner',
        '-loglevel', 'warning',
        '-stats',
        '-i', file,
        '-map', '0:a', # select audio only, remove cover art
        '-f', 'mp3',
        '-c', 'copy',
        '-map_metadata', '-1',
        '-id3v2_version', '0', # strip tags
        '-bitexact',
        tmpfile
    ], check=True)

    with open(tmpfile, 'rb') as tmp:
        mhash = hash_file(tmp)

    try:
        song = context.catalog.register(artists, title, mhash)
    except CatalogError as e:
        err(e)
        sys.exit(1)

    with (open(tmpfile, 'rb') as tmp,
          open(tmpdestfile, 'wb') as tmpdest):
        tmpdest.write(song.tdata)
        copy_file(tmp, tmpdest)

    os.remove(tmpfile)

    destfile = os.path.join(context.root, song.file)
    os.replace(tmpdestfile, destfile)
    context.catalog.save()

    os.remove(file)

    if context.commit:
        message = f'catalog: add {song.id}'
        subprocess.run([
            'git', '-C', context.root, 'commit',
            '-m', message, 'catalog.txt'
        ], check=True)

def import_queue(context):
    try:
        files = os.listdir(context.queue_dir)
    except FileNotFoundError:
        return

    files.sort(key=lambda file: os.path.getmtime(os.path.join(context.queue_dir, file)))

    imports = []

    for file in files:
        if not file.endswith('.mp3'):
            continue
        artists, _, title = file[:-4].partition('.')
        artists = artists.split(',')
        invalid = False
        for artist in artists:
            if not artist_regex.fullmatch(artist):
                warn(f'invalid artist {artist!r}')
                invalid = True
        if not title_regex.fullmatch(title):
            warn(f'invalid title {title!r}')
            invalid = True
        if invalid:
            warn(f'invalid filename {file!r}')
        else:
            imports.append((artists, title, os.path.join(context.queue_dir, file)))

    for artists, title, file in imports:
        msg(f'\033[1;32mimport:\033[0;1m {",".join(artists)} {title}\033[0m')

    if context.no or not imports or not (context.yes or confirm('Proceed?', True)):
        return

    for artists, title, file in imports:
        import_song(context, artists, title, file)

class Context:
    def __init__(self, root, *, no=False, yes=False, commit=False):
        self.root = root
        self.no = no
        self.yes = yes
        self.commit = commit
        self.catalog_file = os.path.join(root, 'catalog.txt')
        self.queue_dir = os.path.join(root, 'queue')
        self.catalog = Catalog(self.catalog_file)

        try:
            self.catalog.load()
        except (OSError, CatalogError) as e:
            err(f'failed to load catalog: {e}')
            sys.exit(1)

    def create_backend(self, param):
        protocol, sep, param = param.partition(':')
        if not sep:
            param = protocol
            protocol = 'file'
        cls = backends.get(protocol)
        if cls is None:
            raise BackendError(f'Unrecognized protocol {protocol!r}')
        return cls(self, param)

##############################################################################
# Sync
##############################################################################

class SyncRemote:
    def __init__(self, catalog, backend):
        self.backend = backend
        self.live, self.dead, self.prunes = catalog.classify_files(backend.list())
        self.pulls = []
        self.pushes = []
        self.renames = []

def sync(context, backends):
    catalog = context.catalog

    try:
        remotes = [SyncRemote(catalog, backend) for backend in backends]
    except (BackendError, OSError) as e:
        err(e)
        sys.exit(1)

    local_files = [
        f'core/{file}'
        for file in os.listdir(os.path.join(context.root, 'core'))
        if file.endswith('.mp3')]

    live, dead, prunes = catalog.classify_files(local_files)

    renames = []

    for song in catalog:
        # ignore songs without an associated file
        if song.mhash is None:
            continue

        if song in live:
            file, thash = live[song]
            if file != song.file:
                # the file exists locally but has the wrong name
                tdata = song.tdata if thash != song.thash else None
                renames.append((file, song.file, tdata))
        else:
            # the song doesn't exist locally, try to find it on a remote
            for remote in remotes:
                if song in remote.live:
                    file, thash = remote.live[song]
                    remote.pulls.append(file)
                    if file != song.file:
                        tdata = song.tdata if thash != song.thash else None
                        renames.append((file, song.file, tdata))
                    break
            else:
                warn(f'unable to find source for {song}')
                continue

        for remote in remotes:
            if song in remote.live:
                file, thash = remote.live[song]
                if file != song.file:
                    # the song exists on the remote but has the wrong name
                    tdata = song.tdata if thash != song.thash else None
                    remote.renames.append((file, song.file, tdata))
            else:
                # the remote doesn't have it; send the file
                remote.pushes.append(song.file)

    # find local files not in the catalog
    for mabbrev, file in dead.items():
        dest = f'old/{mabbrev}.mp3'
        if file != dest:
            renames.append((file, dest, None))

    # find remote files not in the catalog
    for remote in remotes:
        for mabbrev, file in remote.dead.items():
            dest = f'old/{mabbrev}.mp3'
            if file != dest:
                remote.renames.append((file, dest, None))

    for file in prunes:
        msg(f'\033[1;31mremove:\033[0m {file}')

    for remote in remotes:
        for file in remote.pulls:
            msg(f'\033[1;36mpull:\033[0m {file}')

    for src, dest, tdata in renames:
        if tdata is None:
            msg(f'\033[1;34mrename:\033[0m {src} -> {dest}')
        else:
            msg(f'\033[1;35mretag:\033[0m {src} -> {dest}')

    for remote in remotes:
        for file in remote.pushes:
            msg(f'\033[1;36mpush:\033[0m {file}')
        for src, dest, tdata in remote.renames:
            if tdata is None:
                msg(f'\033[1;36mrename:\033[0m {src} -> {dest}')
            else:
                msg(f'\033[1;36mretag:\033[0m {src} -> {dest}')
        for file in remote.prunes:
            msg(f'Would remove {file}')

    if context.no or not (prunes or renames or any(
        remote.pulls or remote.pushes or remote.renames or remote.prunes
        for remote in remotes
    )) or not (context.yes or confirm('Proceed?', True)):
        return

    for file in prunes:
        msg(f'Removing {file}')
        os.remove(os.path.join(context.root, file))

    for remote in remotes:
        if remote.pulls:
            remote.backend.fetch(remote.pulls)

    for src, dest, tdata in renames:
        msg(f'Renaming {src} -> {dest}')
        srcfile = os.path.join(context.root, src)
        destfile = os.path.join(context.root, dest)
        if tdata is not None:
            id3_write(srcfile, tdata)
        os.rename(srcfile, destfile)

    for remote in remotes:
        if remote.pushes or remote.renames or remote.prunes:
            remote.backend.send(remote.pushes, remote.renames, remote.prunes)

##############################################################################
# Check
##############################################################################

def check_file_integrity(context):
    ok = 0
    total = len(context.catalog)
    for song in context.catalog:
        file = song.file
        try:
            with open(os.path.join(context.root, file), 'rb') as f:
                if f.read(10) != id3_header:
                    err(f'{file}: invalid ID3 header')
                    continue
                f.seek(256)
                mhash = hash_file(f)
                if mhash != song.mhash:
                    err(f'{file}: corrupt file')
                    continue
        except FileNotFoundError:
            err(f'{file}: file not found')
            continue
        ok += 1
    print(f'{ok} ok, {total - ok} bad, {total} total')
    if ok != total:
        sys.exit(4)

##############################################################################
# Info
##############################################################################

def print_info(catalog, *, latest=10, artists=10):
    from collections import Counter

    print(f'{len(catalog)} songs')

    if latest > 0:
        print(f'\nLatest {latest} songs:')
        for song in reversed(catalog):
            print(f'  {song}')
            latest -= 1
            if latest == 0:
                break

    if artists > 0:
        counter = Counter(song.artist for song in catalog)
        top = counter.most_common(artists)
        width = max(len(artist) for artist, count in top)
        print(f'\nTop {artists} artists:')
        for artist, count in top:
            print(f'  {artist.rjust(width)}  {"*" * count} ({count})')

##############################################################################
# Command-Line Processing
##############################################################################

def parser_error(message):
    err(message)
    sys.exit(2)

def main():
    import optparse
    parser = optparse.OptionParser(usage='%prog [-ic] [options] [remote...]')
    parser.add_option('-i', '--import', action='store_true', dest='do_import', help='import new music')
    parser.add_option('-c', '--check', action='store_true', help='verify file integrity')
    parser.add_option('-n', '--dry-run', action='store_true', help='do nothing, only show what would happen')
    parser.add_option('-y', '--yes', action='store_true', help='do not prompt for confirmation')
    parser.add_option('--prune', action='store_true', help='prune extraneous music files')
    parser.add_option('--commit', action='store_true', help='commit catalog changes')
    parser.add_option('--dump', action='store_true', help='dump catalog to stdout')
    parser.add_option('-r', '--root', metavar='DIR', default=default_root, help='root directory [default: %default]')
    parser.error = parser_error
    opts, args = parser.parse_args()

    context = Context(
        opts.root,
        no=opts.dry_run,
        yes=opts.yes,
        commit=opts.commit
    )

    if opts.do_import:
        import_queue(context)

    backends = [context.create_backend(arg) for arg in args]
    sync(context, backends)

    if opts.check:
        check_file_integrity(context)

    if opts.dump:
        catalog.write(sys.stdout)

if __name__ == '__main__':
    main()

# vim:tw=78
