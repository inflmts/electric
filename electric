#!/usr/bin/env python3
##############################################################################
#
#         ,/
#       ,'/
#     ,' /___,  888888 88     888888  dP""b8 888888 88""Yb 88  dP""b8
#   .'__   ,'   88__   88     88__   dP   `"   88   88__dP 88 dP   `"
#      / ,'     88""   88  .o 88""   Yb        88   88"Yb  88 Yb
#     /,'       888888 88ood8 888888  YboodP   88   88  Yb 88  YboodP
#    /'
#
# ----------------------------------------------------------------------------
#                           Music Library Manager
# ----------------------------------------------------------------------------
#
#   Copyright (c) 2024-2025 Daniel Li
#
#   This software is available under the MIT License.
#
#   Dependencies:
#     - python 3.8
#     - click
#     - ffmpeg: for import
#     - yt-dlp (optional): import from youtube
#     - adb (optional): for adb backend
#
##############################################################################

import click
from collections import Counter, namedtuple
import datetime
import hashlib
import itertools
import os
import re
import shutil
import subprocess
import sys
import zlib

# output newline on all platforms
sys.stdout.reconfigure(newline='\n')

default_root = os.path.dirname(os.path.realpath(__file__))

song_file_regex = re.compile(r'[0-9a-z\.-]*\.[0-9a-f]{16}\.mp3')
id_regex = re.compile(r'[1-9][0-9]*')
artist_regex = re.compile(r'[0-9a-z]+(?:-[0-9a-z]+)*')
title_regex = artist_regex
date_regex = re.compile(r'([0-9]{4})-([0-9]{2})-([0-9]{2})')
mhash_regex = re.compile(r'[0-9a-f]{64}')

##############################################################################
# Utility Functions
##############################################################################

def err(message):
    sys.stderr.write(f'\033[1;31merror:\033[0m {message}\n')

def warn(message):
    sys.stderr.write(f'\033[1;33mwarning:\033[0m {message}\n')

def msg(message):
    sys.stderr.write(f'{message}\n')

def confirm(prompt, default=False):
    """
    Prompt the user for confirmation.

    If the response is empty (ie. the user simply pressed Enter),
    the specified default is returned if provided, otherwise False.
    If the response is 'Y' or 'y', returns True, otherwise returns False.
    """
    options = '[Y/n]' if default else '[y/N]'
    sys.stderr.write(f'{prompt} {options} ')
    reply = input()
    return default if len(reply) == 0 else reply == 'y' or reply == 'Y'

def safe_rename(src, dest):
    # not actually safe
    if os.path.exists(dest):
        raise FileExistsError(dest)
    os.rename(src, dest)

def copy_and_sha256(srcf, destf):
    sha256 = hashlib.sha256()
    while chunk := srcf.read(65536):
        sha256.update(chunk)
        if destf is not None:
            destf.write(chunk)
    return sha256.hexdigest()

##############################################################################
# ID3
##############################################################################

# Resources:
#   - https://mutagen-specs.readthedocs.io/en/latest/id3/id3v2.4.0-structure.html
#   - https://mutagen-specs.readthedocs.io/en/latest/id3/id3v2.4.0-frames.html
#   - https://en.wikipedia.org/wiki/MP3#File_structure
#   - http://mpgedit.org/mpgedit/mpeg_format/mpeghdr.htm
#   - https://www.datavoyage.com/mpgscript/mpeghdr.htm (same)
#   - http://gabriel.mp3-tech.org/mp3infotag.html
#   - https://forum.powerbasic.com/forum/user-to-user-discussions/programming/54515-lame-header-frame

id3_header = b'ID3\x04\x00\x00\x00\x00\x01\x76'

def id3_encode_uint28(x):
    return bytes((x >> 21 & 0x7f, x >> 14 & 0x7f, x >> 7 & 0x7f, x & 0x7f))

def id3_encode_frame(id, content):
    return id + id3_encode_uint28(len(content)) + b'\x00\x00' + content

def id3_encode_text(id, content):
    return id3_encode_frame(id, b'\x03' + content.encode('utf-8') + b'\x00')

def id3_encode(tags):
    """Encode song tags as a 256-byte ID3v2.4.0 header."""
    data = (id3_header
        + id3_encode_text(b'TIT2', tags.title)
        + id3_encode_text(b'TPE1', tags.artist)
        + id3_encode_text(b'TALB', tags.album))
    if len(data) > 256:
        raise ValueError('ID3 tag exceeds 256 bytes')
    data = data.ljust(256, b'\x00')
    assert len(data) == 256
    return data

def id3_write(file, data):
    assert len(data) == 256
    with open(file, 'r+b') as f:
        if f.read(10) != id3_header:
            raise RuntimeError('Invalid ID3 header')
        assert f.tell() == 10
        f.write(data[10:])

##############################################################################
# Songs
##############################################################################

SongTags = namedtuple('SongTags', ('title', 'artist', 'album'))

class Song:
    """
    Represents a song in the catalog.

    All attributes are readonly except for `mhash`. Note that changing `mhash`
    will cause the computed path to change as well. `mhash` may be None, which
    indicates that the song does not have an associated file; this could mean
    that the song is currently being imported.
    """

    def __init__(self, id, artist, title, date, mhash):
        self.id = id
        self.artist = artist
        self.title = title
        self.date = date
        self.mhash = mhash

        # The artist name and song title are generated by converting their
        # respective identifiers to uppercase and replacing dashes with
        # spaces. For the vast majority of cases, this works fabulously.
        self.tags = SongTags(
            title.upper().replace('-', ' '),
            artist.upper().replace('-', ' '),
            f'E{self.id:04}')
        self.tdata = id3_encode(self.tags)
        self.thash = '%04x' % (zlib.crc32(self.tdata) >> 16 & 0xffff)

    def __str__(self):
        return f'E{self.id:04} ({self.artist}.{self.title})'

    @property
    def mabbrev(self):
        if self.mhash is None:
            raise TypeError(f'Song {self} does not have a mhash')
        return self.mhash[:12]

    @property
    def file(self):
        return f'{self.artist}.{self.title}.{self.mabbrev}{self.thash}.mp3'

    def write(self, f):
        id = self.id
        artist = self.artist
        title = self.title
        date = self.date.strftime('%Y-%m-%d')
        mhash = self.mhash
        if mhash is None:
            raise RuntimeError(f'Song {self} does not have a mhash')
        f.write(f'{id} {artist} {title} {date} {mhash}\n')

##############################################################################
# Catalog
##############################################################################

class Catalog:
    def __init__(self):
        self._songs = {}
        self._lastid = 0

    def __len__(self):
        return len(self._songs)

    def __getitem__(self, id):
        return self._songs[id]

    def __iter__(self):
        return iter(self._songs.values())

    def __reversed__(self):
        return reversed(self._songs.values())

    def __contains__(self, id):
        return id in self._songs

    def add(self, id, artist, title, date, mhash):
        if id <= self._lastid:
            raise RuntimeError(f'Attempted to add {id} after {self._lastid}')
        song = Song(id, artist, title, date, mhash)
        self._songs[id] = song
        self._lastid = id
        return song

    def register(self, artist, title, mhash):
        date = datetime.date.today()
        return self.add(self._lastid + 1, artist, title, date, mhash)

    def get(self, id):
        return self._songs.get(id)

    @classmethod
    def read(cls, f):
        """Read the catalog from a file object."""

        catalog = cls()
        lineno = 0

        try:
            for line in f:
                # increment line number before the loop to catch continue
                lineno += 1
                # remove trailing newline
                line = line[:-1]

                fields = line.split(' ')
                if len(fields) != 5:
                    raise RuntimeError(f'Expected 5 fields but {len(fields)} present')
                id, artist, title, date, mhash = fields

                if not id_regex.fullmatch(id):
                    raise RuntimeError(f'Invalid id {id!r}')
                id = int(id)

                if not artist_regex.fullmatch(artist):
                    raise RuntimeError(f'Invalid artist {artist!r}')

                if not title_regex.fullmatch(title):
                    raise RuntimeError(f'Invalid title {title!r}')

                if not (match := date_regex.fullmatch(date)):
                    raise RuntimeError(f'Invalid date {date!r}')
                y, m, d = match.groups()
                date = datetime.date(int(y), int(m), int(d))

                if not mhash_regex.fullmatch(mhash):
                    raise RuntimeError(f'Invalid mhash {mhash!r}')

                catalog.add(id, artist, title, date, mhash)
        except Exception as e:
            raise RuntimeError(f'Error in catalog at line {lineno}') from e

        return catalog

    def write(self, f):
        """Write the catalog to a file object."""
        for song in self:
            song.write(f)

    def save(self, file):
        tmpfile = file + '.lock'
        tmpf = open(tmpfile, 'x', newline='\n')
        try:
            with tmpf:
                self.write(tmpf)
        except:
            os.remove(tmpfile)
            raise
        os.replace(tmpfile, file)

##############################################################################
# Import
##############################################################################

def import_commit(context, catalog, srcfile, song, commit_message):
    if not os.path.exists(srcfile):
        err(f'nothing to import')
        sys.exit(1)

    tmpfile1 = os.path.join(context.root, 'import~1.mp3')
    tmpfile2 = os.path.join(context.root, 'import~2.mp3')

    # Normalize using ffmpeg. This does a few things:
    #
    #   - makes sure it's actually a mp3
    #   - removes the id3 header so we can add our own
    #   - gets a xing/info header so ffprobe doesn't complain
    #
    subprocess.run(
        ['ffmpeg', '-y',
         '-hide_banner',
         '-loglevel', 'warning',
         '-stats',
         '-i', srcfile,
         '-map', '0:a', # select audio only, remove cover art
         '-f', 'mp3',
         '-c', 'copy',
         '-id3v2_version', '0', # we handle metadata ourselves
         tmpfile1],
        check=True)

    with (open(tmpfile1, 'rb') as src, open(tmpfile2, 'wb') as dest):
        # write metadata and calculate mhash
        dest.write(song.tdata)
        mhash = copy_and_sha256(src, dest)

    # the correct `destfile` is only known after calculating the mhash
    song.mhash = mhash
    destfile = os.path.join(context.music_dir, song.file)
    safe_rename(tmpfile2, destfile)

    # save catalog
    context.save_catalog(catalog)

    # cleanup
    os.remove(srcfile)
    os.remove(tmpfile1)

    # commit
    subprocess.run(
        ['git', '-C', context.root, 'commit',
         '-m', commit_message, 'catalog.txt'],
        check=True)

##############################################################################
# Backends
##############################################################################

backends = {}

def backend(protocol):
    def decorator(cls):
        backends[protocol] = cls
        return cls
    return decorator

# Backends must implement these methods:
#
#   __init__(param)
#       Creates the backend from the user-supplied parameter.
#
#   list()
#       Returns a list of files in the backend.
#
#   sync(local_dir, pulls, pushes, retags, renames, prunes)
#       Executes the specified updates on the remote.
#           - local_dir: the local music directory
#           - pulls: list of files to pull
#           - pushes: list of files to push
#           - renames: list of (src, dest, tdata) of files to rename
#               - src: remote source file
#               - dest: remote destination file
#               - tdata: None or the binary ID3 tags to write to the file
#           - prunes: list of files to remove
#

@backend('file')
class FileBackend:
    def __init__(self, param):
        self.target_dir = param

    def list(self):
        return sorted(file
            for file in os.listdir(self.target_dir)
            if song_file_regex.fullmatch(file))

    def sync(self, local_dir, pulls, pushes, renames, prunes):
        for file in pulls:
            msg(f'Pulling {file}')
            srcfile = os.path.join(self.target_dir, file)
            destfile = os.path.join(local_dir, file)
            shutil.copyfile(srcfile, destfile)

        for file in pushes:
            msg(f'Pushing {file}')
            srcfile = os.path.join(local_dir, file)
            destfile = os.path.join(self.target_dir, file)
            shutil.copyfile(srcfile, destfile)

        for src, dest, tdata in renames:
            msg(f'Renaming {src} -> {dest}')
            srcfile = os.path.join(self.target_dir, src)
            destfile = os.path.join(self.target_dir, dest)
            if tdata is not None:
                id3_write(srcfile, tdata)
            safe_rename(srcfile, destfile)

        for file in prunes:
            msg(f'Removing {file}')
            os.remove(os.path.join(self.target_dir, file))

@backend('adb')
class AdbBackend:
    def __init__(self, param):
        self.target_dir = param or '/storage/emulated/0/Music/core'

    def list(self):
        output = subprocess.run(
            ['adb', 'shell', f'ls \'{self.target_dir}\''],
            stdout=subprocess.PIPE,
            text=True, check=True).stdout
        return [file for file in output.splitlines()
                     if song_file_regex.fullmatch(file)]

    def sync(self, local_dir, pulls, pushes, renames, prunes):
        for file in pulls:
            msg(f'Pulling {file}')
            srcfile = f'{self.target_dir}/{file}'
            destfile = os.path.join(local_dir, file)
            subprocess.run(['adb', 'pull', srcfile, destfile], check=True)

        for file in pushes:
            msg(f'Pushing {file}')
            srcfile = os.path.join(local_dir, file)
            destfile = f'{self.target_dir}/{file}'
            subprocess.run(['adb', 'push', srcfile, destfile], check=True)

        if renames or prunes:
            commands = [f'set -e\ncd \'{self.target_dir}\'\n']
            for src, dest, tdata in renames:
                commands.append(f'echo >&2 \'Renaming {src} -> {dest}\'\n')
                if tdata is not None:
                    escaped = ''.join(f'\\x{b:02x}' for b in tdata)
                    commands.append(f'echo -ne \'{escaped}\' 1<> {src}\n')
                commands.append(f'mv -vnT {src} {dest}\n')
            if prunes:
                commands.append(f'rm -v')
                for file in prunes:
                    commands.append(f' \'{file}\'')
                commands.append('\n')
            subprocess.run(
                ['adb', 'shell'],
                input=''.join(commands),
                text=True, check=True)

##############################################################################
# Command-Line Parsing
##############################################################################

class Context:
    def __init__(self, root):
        self.root = root
        self.catalog_file = os.path.join(root, 'catalog.txt')
        self.music_dir = os.path.join(root, 'core')

    def load_catalog(self):
        with open(self.catalog_file) as f:
            return Catalog.read(f)

    def save_catalog(self, catalog):
        catalog.save(self.catalog_file)

    def create_backend(self, param):
        protocol, sep, param = param.partition(':')
        if not sep:
            param = protocol
            protocol = 'file'
        cls = backends.get(protocol)
        if cls is None:
            err(f'unrecognized protocol {protocol!r}')
            sys.exit(2)
        return cls(param)

@click.group()
@click.option('-r', '--root', metavar='DIR', default=default_root, show_default=True, help='root directory')
@click.pass_context
def main(ctx, root):
    ctx.obj = Context(root)

#-----------------------------------------------------------------------------
# Command: add
#-----------------------------------------------------------------------------

@main.command('add')
@click.option('-f', '--file', metavar='FILE', help='source file')
@click.argument('artist')
@click.argument('title')
@click.pass_obj
def _(context, file, artist, title):
    """Add a song to the library."""

    if file is None:
        file = os.path.join(context.root, 'import.mp3')
    if not artist_regex.fullmatch(artist):
        err(f'invalid artist {artist!r}')
        sys.exit(2)
    if not title_regex.fullmatch(title):
        err(f'invalid title {title!r}')
        sys.exit(2)

    catalog = context.load_catalog()
    song = catalog.register(artist, title, None)
    import_commit(context, catalog, file, song, f'catalog: add {song.id}')

#-----------------------------------------------------------------------------
# Command: replace
#-----------------------------------------------------------------------------

@main.command('replace')
@click.option('-f', '--file', metavar='FILE', help='source file')
@click.argument('id', type=int)
@click.pass_obj
def _(context, file, id):
    """Replace an existing song in the library."""

    if file is None:
        file = os.path.join(context.root, 'import.mp3')

    catalog = context.load_catalog()
    song = catalog.get(id)
    if song is None:
        err(f'no such song: {id}')
        sys.exit(1)
    import_commit(context, catalog, file, song, f'catalog: replace {song.id}')

#-----------------------------------------------------------------------------
# Command: sync
#-----------------------------------------------------------------------------

class SyncRemote:
    def __init__(self, context, param):
        self.backend = context.create_backend(param)
        self.files = self.backend.list()
        self.pulls = []
        self.pushes = []
        self.renames = []
        self.prunes = []

@main.command('sync')
@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
@click.option('--prune', is_flag=True, help='prune extraneous music files')
@click.argument('remotes', nargs=-1)
@click.pass_obj
def _(context, dry_run, yes, prune, remotes):
    """Update the music library."""

    catalog = context.load_catalog()
    remotes = tuple(SyncRemote(context, remote) for remote in remotes)

    local_files = sorted(file
        for file in os.listdir(context.music_dir)
        if song_file_regex.fullmatch(file))

    has_actions = False
    renames = []
    prunes = []

    for song in catalog:
        # song must have an associated file
        assert song.mhash is not None

        song.has_local = True

        # check if the song exists locally with the correct filename
        try:
            local_files.remove(song.file)
        except ValueError:
            pass
        else:
            continue

        # try to find the file locally
        for i, file in enumerate(local_files):
            mabbrev = file[-20:-8]
            thash = file[-8:-4]
            if mabbrev != song.mabbrev:
                continue
            local_files.pop(i)
            src = file
            dest = song.file
            tdata = song.tdata if thash != song.thash else None
            msg(f'\033[1;36mrename:\033[0;1m {song}\033[0m')
            renames.append((src, dest, tdata))
            has_actions = True
            break
        else:
            # try to find a remote to pull the file from
            for remote in remotes:
                if song.file in remote.files:
                    msg(f'\033[1;32mpull:\033[0;1m {song}\033[0m')
                    remote.pulls.append(song.file)
                    has_actions = True
                    break
            else:
                warn(f'unable to find source for {song}')
                song.has_local = False

    # find local files to prune
    for file in local_files:
        if prune:
            msg(f'\033[1;31mprune:\033[0m {file}')
            prunes.append(file)
            has_actions = True
        else:
            warn(f'extraneous file: {file}')

    for remote in remotes:
        # check if the song exists with the correct filename
        for song in catalog:
            try:
                remote.files.remove(song.file)
            except ValueError:
                pass
            else:
                continue

            # try to find the file on the remote
            for i, file in enumerate(remote.files):
                mabbrev = file[-20:-8]
                thash = file[-8:-4]
                if mabbrev != song.mabbrev:
                    continue
                remote.files.pop(i)
                src = file
                dest = song.file
                tdata = song.tdata if thash != song.thash else None
                msg(f'\033[1;36mrename:\033[0;1m {song}\033[0m')
                remote.renames.append((src, dest, tdata))
                has_actions = True
                break
            else:
                # send the file
                if song.has_local:
                    msg(f'\033[1;32mpush:\033[0;1m {song}\033[0m')
                    remote.pushes.append(song.file)
                    has_actions = True

        # find remote files to prune
        for file in remote.files:
            if file not in catalog_files:
                if prune:
                    msg(f'\033[1;31mprune:\033[0m {file}')
                    remote.prunes.append(file)
                    has_actions = True
                else:
                    warn(f'extraneous file: {file}')

    if dry_run or not has_actions:
        return
    if not (yes or confirm('Proceed?', True)):
        sys.exit(2)

    for src, dest, tdata in renames:
        msg(f'Renaming {src} -> {dest}')
        srcfile = os.path.join(context.music_dir, src)
        destfile = os.path.join(context.music_dir, dest)
        if tdata is not None:
            id3_write(srcfile, tdata)
        safe_rename(srcfile, destfile)

    for remote in remotes:
        remote.backend.sync(
            context.music_dir,
            remote.pulls,
            remote.pushes,
            remote.renames,
            remote.prunes)

    for file in prunes:
        msg(f'Removing {file}')
        os.remove(os.path.join(context.music_dir, file))

#-----------------------------------------------------------------------------
# Command: info
#-----------------------------------------------------------------------------

@main.command('info')
@click.option('-l', '--latest', default=10, metavar='N', help='show N latest songs')
@click.option('-a', '--artists', default=10, metavar='N', help='show N most common artists')
@click.argument('songs', type=int, nargs=-1)
@click.pass_obj
def _(context, latest, artists, songs):
    """Print information about the catalog."""

    catalog = context.load_catalog()

    if songs:
        for id in songs:
            song = catalog.get(id)
            if song is None:
                msg(f'{id}: not found')
                continue
            print(f'{song} added {song.date}')
        return

    print(f'{len(catalog)} songs')

    if latest > 0:
        print(f'\nLatest {latest} songs:')
        for song in itertools.islice(reversed(catalog), latest):
            print(f'  {song}')

    if artists > 0:
        counter = Counter(song.artist for song in catalog)
        top = counter.most_common(artists)
        width = max(len(artist) for artist, count in top)
        print(f'\nTop {artists} artists:')
        for artist, count in counter.most_common(artists):
            print(f'  {artist.rjust(width)}  {"*" * count} ({count})')

#-----------------------------------------------------------------------------
# Command: ls-remote
#-----------------------------------------------------------------------------

@main.command('ls-remote', hidden=True)
@click.argument('remote')
@click.pass_obj
def _(context, remote):
    """List files on a remote."""

    backend = context.create_backend(remote)
    for path in backend.list():
        print(path)

#-----------------------------------------------------------------------------
# Command: dump
#-----------------------------------------------------------------------------

@main.command('dump', hidden=True)
@click.pass_obj
def _(context):
    """Dump the catalog to stdout."""

    context.load_catalog().write(sys.stdout)

#-----------------------------------------------------------------------------

if __name__ == '__main__':
    main(help_option_names=['-h', '--help'])

# vim:tw=78
