#!/usr/bin/env python3
##############################################################################
#
#         ,/
#       ,'/
#     ,' /___,  888888 88     888888  dP""b8 888888 88""Yb 88  dP""b8
#   .'__   ,'   88__   88     88__   dP   `"   88   88__dP 88 dP   `"
#      / ,'     88""   88  .o 88""   Yb        88   88"Yb  88 Yb
#     /,'       888888 88ood8 888888  YboodP   88   88  Yb 88  YboodP
#    /'
#
# ----------------------------------------------------------------------------
#                           Music Library Manager
# ----------------------------------------------------------------------------
#
#   Copyright (c) 2024-2025 Daniel Li
#
#   This software is available under the MIT License.
#
#   Dependencies:
#     - python 3.8
#     - click
#     - ffmpeg (recommended): for import reformatting
#     - adb (optional): for adb backend
#
##############################################################################

import click
from collections import Counter, namedtuple
import datetime
import hashlib
import itertools
import operator
import os
import re
import shlex
import shutil
import subprocess
import sys
import tempfile
import zlib

# output newline on all platforms
sys.stdout.reconfigure(newline='\n')

default_root = os.path.dirname(os.path.realpath(__file__))

# The list of valid groups.
GROUPS = ('core', 'extra')

song_file_regex = re.compile(r'[0-9a-z\.-]*\.[0-9a-f]{16}\.mp3')
import_file_regex = re.compile(r'([a-z]+)\.([0-9a-z]+(?:-[0-9a-z]+)*)\.([0-9a-z]+(?:-[0-9a-z]+)*)\.mp3')
replace_file_regex = re.compile(r'\+(\d+)\.mp3')

##############################################################################
# Utility Functions
##############################################################################

def err(message):
    sys.stderr.write(f'\033[1;31merror:\033[0m {message}\n')

def warn(message):
    sys.stderr.write(f'\033[1;33mwarning:\033[0m {message}\n')

def msg(message):
    sys.stderr.write(f'{message}\n')

def confirm(prompt, default=False):
    """Prompt the user for confirmation.

    If the response is empty (ie. the user simply pressed Enter),
    the specified default is returned if provided, otherwise False.
    If the response is 'Y' or 'y', returns True, otherwise returns False.
    """
    reply = input(prompt)
    return default if len(reply) == 0 else reply == 'y' or reply == 'Y'

def read_exact(f, size):
    buf = f.read(size)
    if len(buf) < size:
        raise Exception('Unexpected end of file')
    return buf

def safe_rename(src, dest):
    # not actually safe
    if os.path.exists(dest):
        raise FileExistsError(dest)
    os.rename(src, dest)

##############################################################################
# Tags
##############################################################################

id3_header = b'ID3\x04\x00\x00\x00\x00\x01\x76'
mp3_bitrate_table = [None, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, None]
mp3_frequency_table = [44100, 48000, 32000, None]

def id3_encode_uint28(x):
    return bytes((x >> 21 & 0x7f, x >> 14 & 0x7f, x >> 7 & 0x7f, x & 0x7f))

def id3_encode_frame(id, content):
    return id + id3_encode_uint28(len(content)) + b'\x00\x00' + content

def id3_encode_text(id, content):
    return id3_encode_frame(id, b'\x03' + content.encode('utf-8') + b'\x00')

def id3_encode(tags):
    """Encode song tags as a 256-byte ID3v2.4.0 header."""
    data = (id3_header
        + id3_encode_text(b'TIT2', tags.title)
        + id3_encode_text(b'TPE1', tags.artist)
        + id3_encode_text(b'TALB', tags.album))
    if len(data) > 256:
        raise ValueError('ID3 tag exceeds 256 bytes')
    data = data.ljust(256, b'\x00')
    assert len(data) == 256
    return data

def id3_decode_int28(b):
    return (b[0] & 0x7f) << 21 | (b[1] & 0x7f) << 14 | (b[2] & 0x7f) << 7 | (b[3] & 0x7f)

def id3_skip(f):
    """Skip the ID3 header in a seekable readable stream."""
    header = read_exact(f, 10)
    if header[0:3] != b'ID3':
        raise Exception('id3: invalid magic')
    if header[5] != 0:
        raise Exception(f'id3: unrecognized flags ({header[5]:8b})')
    size = id3_decode_int28(header[6:10])
    f.seek(size, os.SEEK_CUR)

#def mp3_read_frame(f):
#    """Read an MP3 frame."""
#    header = f.read(4)
#    if not header:
#        return None
#    b0, b1, b2, b3 = header
#    if b0 != 0b11111111 or b1 & 0b11111110 != 0b11111010:
#        raise Exception('Unrecognized frame header')
#    bitrate = mp3_bitrate_table[b2 >> 4 & 0b1111]
#    if bitrate is None:
#        raise Exception('Invalid bitrate index')
#    freq = mp3_frequency_table[b2 >> 2 & 0b11]
#    if freq is None:
#        raise Exception('Invalid frequency index')
#    padding = b2 >> 1 & 0b1
#    if b2 & 0b1:
#        raise Exception('Private bit set')
#    if b3 & 0b11:
#        raise Exception('Emphasis bit set')
#    size = 144000 * bitrate // freq + padding
#    return header + read_exact(f, size - 4)

def mp3_normalize(srcf, destf, tdata):
    """Replace the ID3 header and calculate the mhash."""
    id3_skip(srcf)
    destf.write(tdata)
    sha256 = hashlib.sha256()
    while chunk := srcf.read(65536):
        sha256.update(chunk)
        destf.write(chunk)
    return sha256.hexdigest()

##############################################################################
# Songs
##############################################################################

SongTags = namedtuple('SongTags', ('title', 'artist', 'album'))

class Song:
    """
    Represents a song in the catalog.

    All attributes are readonly except for `mhash`. Note that changing `mhash`
    will cause the computed path to change as well.

    The `mhash` attribute may be None, which indicates that the song is not
    associated with a file. This can occur for a few reasons:

        - The song is currently being imported. It has been added to the
          catalog to obtain a song id, which is required to correctly tag the
          music file. For performance reasons, the mhash is calculated at the
          same time as the music file is being normalized.

        - The song has been dropped from the library but is still retained in
          the catalog for archival purposes.
    """

    def __init__(self, id, group, artist, title, date, mhash):
        self.id = id
        self.group = group
        self.artist = artist
        self.title = title
        self.date = date
        self.mhash = mhash

        # The artist name and song title are generated by converting their
        # respective identifiers to uppercase and replacing dashes with
        # spaces. For the vast majority of cases, this works fabulously.
        self.tags = SongTags(
            title.upper().replace('-', ' '),
            artist.upper().replace('-', ' '),
            self.eid)
        self.tdata = id3_encode(self.tags)
        self.thash = '%04x' % (zlib.crc32(self.tdata) >> 16 & 0xffff)

    def __str__(self):
        return f'{self.eid}[{self.group}.{self.artist}.{self.title}]'

    @property
    def eid(self):
        return f'E{self.id:04}'

    @property
    def mabbrev(self):
        if self.mhash is None:
            raise TypeError(f'Song {self} does not have a mhash')
        return self.mhash[:12]

    @property
    def path(self):
        return f'{self.group}/{self.artist}.{self.title}.{self.mabbrev}{self.thash}.mp3'

    def write(self, f):
        id = self.id
        group = self.group
        artist = self.artist
        title = self.title
        date = self.date.strftime('%Y-%m-%d')
        mhash = self.mhash
        f.write(f'{id} {group} {artist} {title} {date} {mhash}\n')

##############################################################################
# Catalog
##############################################################################

class Catalog:
    def __init__(self):
        self._songs = {}
        self._lastid = 0

    def __len__(self):
        return len(self._songs)

    def __getitem__(self, id):
        return self._songs[id]

    def __iter__(self):
        return iter(self._songs.values())

    def __reversed__(self):
        return reversed(self._songs.values())

    def __contains__(self, id):
        return id in self._songs

    @property
    def lastid(self):
        return self._lastid

    def add(self, id, group, artist, title, date, mhash):
        assert id > self._lastid
        song = Song(id, group, artist, title, date, mhash)
        self._songs[id] = song
        self._lastid = id
        return song

    def register(self, group, artist, title, mhash):
        date = datetime.date.today()
        return self.add(self._lastid + 1, group, artist, title, date, mhash)

    def replace(self, id, group, artist, title, date, mhash):
        if id not in self._songs:
            raise KeyError(id)
        song = Song(id, group, artist, title, date, mhash)
        self._songs[id] = song
        return song

    def get(self, id):
        return self._songs.get(id)

    def write(self, f):
        """Write the catalog to a file object."""
        for song in self:
            song.write(f)

class CatalogParseError(Exception):
    pass

def read_catalog(file):
    """Read the catalog from a file object."""

    id_regex = re.compile(r'[1-9][0-9]*')
    artist_regex = re.compile(r'[0-9a-z]+(?:-[0-9a-z]+)*')
    title_regex = artist_regex
    date_regex = re.compile(r'([0-9]{4})-([0-9]{2})-([0-9]{2})')
    mhash_regex = re.compile(r'[0-9a-f]{64}')

    catalog = Catalog()
    ln = 0

    def fail(message):
        raise CatalogParseError(f'line {ln}: {message}')

    for line in file:
        # increment line number before the loop to catch continue
        ln += 1
        # remove trailing newline
        line = line[:-1]

        fields = line.split(' ')
        if len(fields) != 6:
            fail(f'Expected 6 fields but {len(fields)} present')
        id, group, artist, title, date, mhash = fields

        if not id_regex.fullmatch(id):
            fail(f'Invalid id {id!r}')
        id = int(id)

        if group not in GROUPS:
            fail(f'Invalid group {group!r}')

        if not artist_regex.fullmatch(artist):
            fail(f'Invalid artist {artist!r}')

        if not title_regex.fullmatch(title):
            fail(f'Invalid title {title!r}')

        if not (match := date_regex.fullmatch(date)):
            fail(f'Invalid date {date!r}')
        y, m, d = match.groups()
        date = datetime.date(int(y), int(m), int(d))

        if not mhash_regex.fullmatch(mhash):
            fail(f'Invalid mhash {mhash!r}')

        catalog.add(id, group, artist, title, date, mhash)

    return catalog

class File:
    def __init__(self, path):
        # `path` MUST be a valid path
        self.path = path
        self.mabbrev = path[-20:-8]
        self.thash = path[-8:-4]
        self.preserve = False # currently not used

def get_update_operations(catalog, paths, source=None, allow_retag=True):
    """
    Determine the operations required to satisfy the catalog given an iterable
    of existing paths and an optional external source to retrieve missing
    files from. Returns a tuple of three lists:

        transfers: list of (src, dest) or None if no `source` was provided
        renames: list of (src, dest, tdata), tdata may be None
        prunes: list of paths to delete
    """

    files = {path: File(path) for path in paths}

    # find songs without a file
    missing = []
    for song in catalog:
        # ignore songs without an associated file
        if song.mhash is None:
            continue
        file = files.pop(song.path, None)
        if file is None:
            missing.append(song)

    # find files that can be renamed/retagged
    transfers = [] if source is not None else None
    renames = []
    for song in missing:
        for file in files.values():
            if file.mabbrev != song.mabbrev:
                continue
            retag = song.thash != file.thash
            if retag and not allow_retag:
                continue
            del files[file.path]
            msg(f'\033[1;36m** {"retag" if retag else "rename"}:\033[0m {song}')
            renames.append((file.path, song.path, song.tdata if retag else None))
            break
        else:
            if source is not None:
                for path in source:
                    if path == song.path:
                        msg(f'\033[1;36m** pull:\033[0m {song}')
                        transfers.append((path, song.path))
                        break
                else:
                    warn(f'unable to find source for {song}')
            else:
                warn(f'unable to find source for {song}')

    # find files to prune
    prunes = []
    for file in files.values():
        if not file.preserve:
            if prune:
                msg(f'\033[1;31prune:\033[0m {file.path}')
                prunes.append(file.path)
            else:
                warn(f'orphan: {file.path}')

    return transfers, renames, prunes

def get_import_operations(catalog, queue_dir):
    """
    Scan the specified queue directory for files to import/replace existing
    songs with. Returns a list of tuples (song, file), where `file` is the
    basename of the source file relative to the queue directory. Note that
    this modifies the catalog to include any new songs.
    """

    # sort by modification time, oldest first
    entries = sorted(os.scandir(queue_dir),
                     key=lambda entry: entry.stat().st_mtime_ns)

    imports = []
    for entry in entries:
        file = entry.name
        if match := import_file_regex.fullmatch(file):
            group, artist, title = match.groups()
            if group not in GROUPS:
                warn(f'import {file!r}: invalid group {group!r}')
                continue
            song = catalog.register(group, artist, title, None)
            msg(f'\033[1;32m** import:\033[0m {song}')
            msg(f'    title: {song.tags.title}')
            msg(f'    artist: {song.tags.artist}')
            msg(f'    album: {song.tags.album}')
            imports.append((song, file))
            continue
        if match := replace_file_regex.fullmatch(file):
            id = int(match.group(1))
            song = catalog.get(id)
            if song is None:
                warn(f'import {file!r}: song {id} doesn\'t exist')
                continue
            msg(f'\033[1;32m** replace:\033[0m {song}')
            imports.append((song, file))
            continue

    return imports

def list_local(root):
    paths = []
    for group in GROUPS:
        for file in os.listdir(os.path.join(root, group)):
            file = os.path.normcase(file)
            path = f'{group}/{file}'
            if song_file_regex.fullmatch(file):
                paths.append(path)
            elif file != 'folder.jpg':
                warn(f'ignoring file {path!r}')
    return paths

def write_tdata(file, tdata):
    assert len(tdata) == 256
    with open(file, 'r+b') as f:
        if f.read(10) != id3_header:
            raise Exception('Invalid ID3 header')
        assert f.tell() == 10
        f.write(tdata[10:])

def execute_local_operations(root, renames, prunes):
    # process renames/retags
    for src, dest, tdata in renames:
        msg(f'Renaming {src} -> {dest}')
        srcfile = os.path.join(root, src)
        destfile = os.path.join(root, dest)
        if tdata is not None:
            write_tdata(srcfile, tdata)
        safe_rename(srcfile, destfile)

    # process prunes
    for path in prunes:
        msg(f'Removing {path}')
        os.remove(os.path.join(root, path))

def execute_import_operations(context, queue_dir, imports):
    root = context.root
    for song, file in imports:
        msg(f'Importing {song}')
        srcfile = os.path.join(queue_dir, file)
        tmpfd, tmpfile = tempfile.mkstemp(prefix='import-', suffix='.mp3~', dir=queue_dir)
        with open(srcfile, 'rb') as srcf, open(tmpfd, 'wb') as tmpf:
            mhash = mp3_normalize(srcf, tmpf, song.tdata)
        song.mhash = mhash
        # the correct `destfile` is only known after calculating the mhash
        destfile = os.path.join(root, song.path)
        safe_rename(tmpfile, destfile)

    context.save_catalog()

    # cleanup
    for song, file in imports:
        msg(f'Cleaning up {file}')
        os.remove(os.path.join(queue_dir, file))

##############################################################################
# Backends
##############################################################################

backends = {}

def backend(name):
    def decorator(cls):
        backends[name] = cls
        return cls
    return decorator

# Backends must implement these methods:
#
#   list()
#       Returns a list of paths in the backend.
#
#   push(root, transfers, renames, prunes)
#       Executes the specified updates on the remote.
#           - transfers: list of (src, dest) of files to push
#               - src: local source path
#               - dest: remote destination path
#           - renames: list of (src, dest, tdata) of files to rename
#               - src: remote source path
#               - dest: remote destination path
#               - tdata: None or the binary ID3 tags to write to the file
#           - prunes: list of paths to remove
#
#   pull(root, transfers)
#       Retrieves files from the remote.
#           - transfers: list of (src, dest) of files to pull
#               - src: remote source path
#               - dest: local destination path
#

@backend('file')
class FileBackend:
    def __init__(self, root):
        self.root = root

    @classmethod
    def create(cls, param):
        return cls(param)

    def list(self):
        return list_local(self.root)

    def push(self, root, transfers, renames, prunes):
        for src, dest in transfers:
            msg(f'Pushing {src} -> {dest}')
            srcfile = os.path.join(root, src)
            destfile = os.path.join(self.root, dest)
            shutil.copyfile(srcfile, destfile)
        execute_local_operations(self.root, renames, prunes)

    def pull(self, root, transfers):
        for src, dest in transfers:
            msg(f'Pulling {src} -> {dest}')
            srcfile = os.path.join(self.root, src)
            destfile = os.path.join(root, dest)
            shutil.copyfile(srcfile, destfile)

@backend('adb')
class AdbBackend:
    def __init__(self, root=None):
        self.root = root if root is not None else '/storage/emulated/0/Music'

    @classmethod
    def create(cls, param):
        return cls(param or None)

    def list(self):
        output = subprocess.run(
            ['adb', 'shell'],
            input=f'cd {shlex.quote(self.root)} && '
                  f'find {" ".join(GROUPS)} -mindepth 1 -maxdepth 1 -name "*.mp3"',
            stdout=subprocess.PIPE,
            text=True, check=True).stdout
        return [path for path in output.splitlines()
                     if song_file_regex.fullmatch(path.partition('/')[2])]

    def push(self, root, transfers, renames, prunes):
        for src, dest in transfers:
            msg(f'Pushing {src} -> {dest}')
            srcfile = os.path.join(root, src)
            subprocess.run(['adb', 'push', srcfile, dest], check=True)

        commands = [f'set -eC\ncd {shlex.quote(self.root)}\n']
        for src, dest, tdata in renames:
            assert tdata is None
            commands.append(f'echo >&2 "Renaming {src} -> {dest}"\n')
            commands.append(f'mv -nT {src} {dest}\n')
        if prunes:
            commands.append(f'echo >&2 "Pruning {len(prunes)} files..."\n'
                            f'rm {" ".join(prunes)}\n')

        subprocess.run(
            ['adb', 'shell'],
            input=''.join(commands),
            text=True)

    def pull(self, root, transfers):
        for src, dest in transfers:
            msg(f'Pulling {src} -> {dest}')
            destfile = os.path.join(root, dest)
            subprocess.run(['adb', 'pull', src, destfile], check=True)

##############################################################################
# Command-Line Parsing
##############################################################################

class Context:
    def __init__(self, root):
        self.root = root
        self.catalog_file = os.path.join(root, 'catalog.txt')
        self._catalog = None

    def catalog(self):
        if self._catalog is None:
            self.load_catalog()
        return self._catalog

    def load_catalog(self):
        with open(self.catalog_file) as f:
            self._catalog = read_catalog(f)
        return self._catalog

    def save_catalog(self):
        with open(self.catalog_file, 'w', newline='\n') as f:
            self._catalog.write(f)

    def create_backend(self, param):
        name = 'file'
        mat = re.match(r'^[a-z]+:', param)
        if mat:
            name = param[:mat.end() - 1]
            param = param[mat.end():]
        cls = backends.get(name)
        if cls is None:
            err(f'unrecognized backend name {name!r}')
            sys.exit(1)
        return cls.create(param)

@click.group()
@click.option('-r', '--root', metavar='DIR', default=default_root, show_default=True, help='root directory')
@click.pass_context
def main(ctx, root):
    ctx.obj = Context(root)

#-----------------------------------------------------------------------------
# Command: update
#-----------------------------------------------------------------------------

@main.command()
@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
@click.option('--prune', is_flag=True, help='prune extraneous music files')
@click.option('--no-import', is_flag=True, help='do not import new songs')
@click.argument('remote', required=False)
@click.pass_obj
def update(context, dry_run, yes, prune, no_import, remote):
    """Update the music library.

    Rename, retag, and optionally pull files from a remote to match the
    catalog. In addition, look for files in the queue directory to to import
    as new songs or replace existing songs.
    """
    root = context.root
    queue_dir = os.path.join(root, 'queue')
    catalog = context.catalog()
    files = list_local(root)

    if remote is not None:
        backend = context.create_backend(remote)
        remote_files = backend.list()
    else:
        remote_files = None

    transfers, renames, prunes = get_update_operations(catalog, files, source=remote_files)
    imports = None if no_import else get_import_operations(catalog, queue_dir)

    if dry_run or not (transfers or renames or prunes or imports):
        return

    if not (yes or confirm('Proceed [Y/n]? ', True)):
        sys.exit(2)

    if transfers:
        backend.pull(transfers)
    execute_local_operations(root, renames, prunes)
    if not no_import:
        execute_import_operations(context, queue_dir, imports)

#-----------------------------------------------------------------------------
# Command: push
#-----------------------------------------------------------------------------

@main.command()
@click.option('-n', '--dry-run', is_flag=True, help='do nothing, only show what would happen')
@click.option('-y', '--yes', is_flag=True, help='do not prompt for confirmation')
@click.option('--prune', is_flag=True, help='prune extraneous files')
@click.argument('remote')
@click.pass_obj
def push(context, dry_run, yes, prune, remote):
    """Send files to a remote."""
    root = context.root
    catalog = context.catalog()
    backend = context.create_backend(remote)

    local_files = list_local(root)
    remote_files = backend.list()
    transfers, renames, prunes = get_update_operations(catalog, remote_files, source=local_files)

    if dry_run or not (transfers or renames or prunes):
        return

    if not (yes or confirm('Proceed [Y/n]? ', True)):
        sys.exit(2)

    backend.push(root, transfers, renames, prunes)

#-----------------------------------------------------------------------------
# Command: info
#-----------------------------------------------------------------------------

@main.command()
@click.option('-l', '--latest', default=10, metavar='N', show_default=True, help='show N latest songs')
@click.option('-a', '--artists', default=10, metavar='N', show_default=True, help='show N most common artists')
@click.argument('songs', type=int, nargs=-1)
@click.pass_obj
def info(context, latest, artists, songs):
    """Print information about the catalog."""
    catalog = context.catalog()
    if songs:
        for id in songs:
            song = catalog.get(id)
            if song is None:
                msg(f'{id}: not found')
                continue
            print(f'{song} added {song.date}')
    else:
        print(f'{len(catalog)} songs')
        if latest > 0:
            print(f'\nLatest {latest} songs:')
            for song in itertools.islice(reversed(catalog), latest):
                print(f'  {song.eid}  {song.date}  {song.group:5}  {song.artist}.{song.title}')
        if artists > 0:
            counter = Counter(song.artist for song in catalog)
            top = counter.most_common(artists)
            width = max(len(artist) for artist, count in top)
            print(f'\nTop {artists} artists:')
            for artist, count in counter.most_common(artists):
                print(f'  {artist.rjust(width)}  {"*" * count} ({count})')

#-----------------------------------------------------------------------------
# Command: ls-remote
#-----------------------------------------------------------------------------

@main.command(hidden=True)
@click.argument('remote')
@click.pass_obj
def ls_remote(context, remote):
    """List files on a remote."""
    backend = context.create_backend(remote)
    for path in backend.list():
        print(path)

#-----------------------------------------------------------------------------
# Command: dump
#-----------------------------------------------------------------------------

@main.command(hidden=True)
@click.pass_obj
def dump(context):
    """Dump the catalog to stdout.

    This is mainly for debugging the catalog parser and writer. The output
    should be identical to the input catalog file.
    """
    context.catalog().write(sys.stdout)

#-----------------------------------------------------------------------------
# Command: mp3norm
#-----------------------------------------------------------------------------

@main.command(hidden=True)
@click.argument('title')
@click.argument('artist')
@click.argument('album')
@click.argument('src')
@click.argument('dest')
@click.pass_obj
def mp3norm(context, title, artist, album, src, dest):
    """Normalize an MP3 file."""
    tdata = id3_encode(SongTags(title, artist, album))
    with open(src, 'rb') as inf, open(dest, 'wb') as outf:
        mhash = mp3_normalize(inf, outf, tdata)
    msg(f'mhash: {mhash}')

#-----------------------------------------------------------------------------

if __name__ == '__main__':
    main(help_option_names=['-h', '--help'])

# vim:tw=78
